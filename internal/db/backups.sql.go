// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: backups.sql

package db

import (
	"context"
	"database/sql"
)

const countBackups = `-- name: CountBackups :one
SELECT COUNT(*) as total FROM backup_history
`

func (q *Queries) CountBackups(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackups)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createBackupRecord = `-- name: CreateBackupRecord :one
INSERT INTO backup_history (
    id, filename, file_path, file_size, backup_type, storage_type,
    s3_bucket, s3_key, status, created_by, started_at
) VALUES (
    ?1, ?2, ?3, ?4,
    ?5, ?6, ?7,
    ?8, ?9, ?10, datetime('now')
)
RETURNING id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at
`

type CreateBackupRecordParams struct {
	ID          string         `json:"id"`
	Filename    string         `json:"filename"`
	FilePath    sql.NullString `json:"file_path"`
	FileSize    int64          `json:"file_size"`
	BackupType  string         `json:"backup_type"`
	StorageType string         `json:"storage_type"`
	S3Bucket    sql.NullString `json:"s3_bucket"`
	S3Key       sql.NullString `json:"s3_key"`
	Status      string         `json:"status"`
	CreatedBy   sql.NullString `json:"created_by"`
}

func (q *Queries) CreateBackupRecord(ctx context.Context, arg CreateBackupRecordParams) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, createBackupRecord,
		arg.ID,
		arg.Filename,
		arg.FilePath,
		arg.FileSize,
		arg.BackupType,
		arg.StorageType,
		arg.S3Bucket,
		arg.S3Key,
		arg.Status,
		arg.CreatedBy,
	)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.BackupType,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Key,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBackup = `-- name: DeleteBackup :exec
DELETE FROM backup_history
WHERE id = ?1
`

func (q *Queries) DeleteBackup(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteBackup, id)
	return err
}

const deleteOldBackups = `-- name: DeleteOldBackups :exec
DELETE FROM backup_history
WHERE created_at < datetime('now', ?1 || ' days')
  AND status = 'completed'
`

func (q *Queries) DeleteOldBackups(ctx context.Context, daysAgo sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteOldBackups, daysAgo)
	return err
}

const getBackup = `-- name: GetBackup :one
SELECT id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at FROM backup_history
WHERE id = ?1
LIMIT 1
`

func (q *Queries) GetBackup(ctx context.Context, id string) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, getBackup, id)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.BackupType,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Key,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBackupsByType = `-- name: GetBackupsByType :many
SELECT id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at FROM backup_history
WHERE backup_type = ?1
ORDER BY created_at DESC
LIMIT ?2
`

type GetBackupsByTypeParams struct {
	BackupType string `json:"backup_type"`
	LimitVal   int64  `json:"limit_val"`
}

func (q *Queries) GetBackupsByType(ctx context.Context, arg GetBackupsByTypeParams) ([]BackupHistory, error) {
	rows, err := q.db.QueryContext(ctx, getBackupsByType, arg.BackupType, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupHistory
	for rows.Next() {
		var i BackupHistory
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FilePath,
			&i.FileSize,
			&i.BackupType,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Key,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedBy,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupsInProgress = `-- name: GetBackupsInProgress :many
SELECT id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at FROM backup_history
WHERE status IN ('pending', 'in_progress')
ORDER BY started_at DESC
`

func (q *Queries) GetBackupsInProgress(ctx context.Context) ([]BackupHistory, error) {
	rows, err := q.db.QueryContext(ctx, getBackupsInProgress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupHistory
	for rows.Next() {
		var i BackupHistory
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FilePath,
			&i.FileSize,
			&i.BackupType,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Key,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedBy,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBackup = `-- name: GetLatestBackup :one
SELECT id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at FROM backup_history
WHERE status = 'completed'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestBackup(ctx context.Context) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, getLatestBackup)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.BackupType,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Key,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listBackups = `-- name: ListBackups :many
SELECT id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at FROM backup_history
ORDER BY created_at DESC
LIMIT ?2 OFFSET ?1
`

type ListBackupsParams struct {
	OffsetVal int64 `json:"offset_val"`
	LimitVal  int64 `json:"limit_val"`
}

func (q *Queries) ListBackups(ctx context.Context, arg ListBackupsParams) ([]BackupHistory, error) {
	rows, err := q.db.QueryContext(ctx, listBackups, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupHistory
	for rows.Next() {
		var i BackupHistory
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FilePath,
			&i.FileSize,
			&i.BackupType,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Key,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedBy,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBackupComplete = `-- name: UpdateBackupComplete :one
UPDATE backup_history
SET status = 'completed',
    file_size = ?1,
    completed_at = datetime('now')
WHERE id = ?2
RETURNING id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at
`

type UpdateBackupCompleteParams struct {
	FileSize int64  `json:"file_size"`
	ID       string `json:"id"`
}

func (q *Queries) UpdateBackupComplete(ctx context.Context, arg UpdateBackupCompleteParams) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, updateBackupComplete, arg.FileSize, arg.ID)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.BackupType,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Key,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateBackupS3Key = `-- name: UpdateBackupS3Key :exec
UPDATE backup_history
SET s3_key = ?1
WHERE id = ?2
`

type UpdateBackupS3KeyParams struct {
	S3Key sql.NullString `json:"s3_key"`
	ID    string         `json:"id"`
}

func (q *Queries) UpdateBackupS3Key(ctx context.Context, arg UpdateBackupS3KeyParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupS3Key, arg.S3Key, arg.ID)
	return err
}

const updateBackupStatus = `-- name: UpdateBackupStatus :one
UPDATE backup_history
SET status = ?1,
    error_message = ?2,
    completed_at = CASE WHEN sqlc.arg(status) IN ('completed', 'failed') THEN datetime('now') ELSE completed_at END
WHERE id = ?3
RETURNING id, filename, file_path, file_size, backup_type, storage_type, s3_bucket, s3_key, status, error_message, created_by, started_at, completed_at, created_at
`

type UpdateBackupStatusParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateBackupStatus(ctx context.Context, arg UpdateBackupStatusParams) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, updateBackupStatus, arg.Status, arg.ErrorMessage, arg.ID)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.BackupType,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Key,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedBy,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}
