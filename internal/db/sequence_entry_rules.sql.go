// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sequence_entry_rules.sql

package db

import (
	"context"
	"database/sql"
)

const countActiveSequencesForContact = `-- name: CountActiveSequencesForContact :one
SELECT COUNT(*) as count
FROM contact_sequence_state css
JOIN email_sequences es ON es.id = css.sequence_id
WHERE css.contact_id = ?1
  AND css.is_active = 1
  AND css.completed_at IS NULL
  AND css.unsubscribed_at IS NULL
  AND es.sequence_type = 'lifecycle'
`

func (q *Queries) CountActiveSequencesForContact(ctx context.Context, contactID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveSequencesForContact, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEntryRule = `-- name: CreateEntryRule :one
INSERT INTO sequence_entry_rules (id, sequence_id, trigger_type, source_id, priority, is_active, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, datetime('now'))
RETURNING id, sequence_id, trigger_type, source_id, priority, is_active, created_at
`

type CreateEntryRuleParams struct {
	ID          string        `json:"id"`
	SequenceID  string        `json:"sequence_id"`
	TriggerType string        `json:"trigger_type"`
	SourceID    string        `json:"source_id"`
	Priority    sql.NullInt64 `json:"priority"`
	IsActive    sql.NullInt64 `json:"is_active"`
}

func (q *Queries) CreateEntryRule(ctx context.Context, arg CreateEntryRuleParams) (SequenceEntryRule, error) {
	row := q.db.QueryRowContext(ctx, createEntryRule,
		arg.ID,
		arg.SequenceID,
		arg.TriggerType,
		arg.SourceID,
		arg.Priority,
		arg.IsActive,
	)
	var i SequenceEntryRule
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.TriggerType,
		&i.SourceID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEntryRule = `-- name: DeleteEntryRule :exec
DELETE FROM sequence_entry_rules WHERE id = ?1
`

func (q *Queries) DeleteEntryRule(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteEntryRule, id)
	return err
}

const deleteEntryRulesBySequence = `-- name: DeleteEntryRulesBySequence :exec
DELETE FROM sequence_entry_rules WHERE sequence_id = ?1
`

func (q *Queries) DeleteEntryRulesBySequence(ctx context.Context, sequenceID string) error {
	_, err := q.db.ExecContext(ctx, deleteEntryRulesBySequence, sequenceID)
	return err
}

const getActiveEntryRuleForTrigger = `-- name: GetActiveEntryRuleForTrigger :many
SELECT ser.id, ser.sequence_id, ser.trigger_type, ser.source_id, ser.priority, ser.is_active, ser.created_at, es.name as sequence_name, es.sequence_type
FROM sequence_entry_rules ser
JOIN email_sequences es ON es.id = ser.sequence_id
WHERE ser.trigger_type = ?1
  AND ser.source_id = ?2
  AND ser.is_active = 1
  AND es.is_active = 1
ORDER BY ser.priority
`

type GetActiveEntryRuleForTriggerParams struct {
	TriggerType string `json:"trigger_type"`
	SourceID    string `json:"source_id"`
}

type GetActiveEntryRuleForTriggerRow struct {
	ID           string         `json:"id"`
	SequenceID   string         `json:"sequence_id"`
	TriggerType  string         `json:"trigger_type"`
	SourceID     string         `json:"source_id"`
	Priority     sql.NullInt64  `json:"priority"`
	IsActive     sql.NullInt64  `json:"is_active"`
	CreatedAt    sql.NullString `json:"created_at"`
	SequenceName string         `json:"sequence_name"`
	SequenceType sql.NullString `json:"sequence_type"`
}

func (q *Queries) GetActiveEntryRuleForTrigger(ctx context.Context, arg GetActiveEntryRuleForTriggerParams) ([]GetActiveEntryRuleForTriggerRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveEntryRuleForTrigger, arg.TriggerType, arg.SourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveEntryRuleForTriggerRow
	for rows.Next() {
		var i GetActiveEntryRuleForTriggerRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceID,
			&i.TriggerType,
			&i.SourceID,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.SequenceName,
			&i.SequenceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveSequenceForContact = `-- name: GetActiveSequenceForContact :one
SELECT css.id, css.contact_id, css.sequence_id, css.current_position, css.is_active, css.started_at, css.completed_at, css.unsubscribed_at, css.paused_at, es.name as sequence_name, es.sequence_type
FROM contact_sequence_state css
JOIN email_sequences es ON es.id = css.sequence_id
WHERE css.contact_id = ?1
  AND css.is_active = 1
  AND css.completed_at IS NULL
  AND css.unsubscribed_at IS NULL
  AND es.sequence_type = 'lifecycle'
LIMIT 1
`

type GetActiveSequenceForContactRow struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	CurrentPosition sql.NullInt64  `json:"current_position"`
	IsActive        sql.NullInt64  `json:"is_active"`
	StartedAt       sql.NullString `json:"started_at"`
	CompletedAt     sql.NullString `json:"completed_at"`
	UnsubscribedAt  sql.NullString `json:"unsubscribed_at"`
	PausedAt        sql.NullString `json:"paused_at"`
	SequenceName    string         `json:"sequence_name"`
	SequenceType    sql.NullString `json:"sequence_type"`
}

func (q *Queries) GetActiveSequenceForContact(ctx context.Context, contactID sql.NullString) (GetActiveSequenceForContactRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveSequenceForContact, contactID)
	var i GetActiveSequenceForContactRow
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SequenceID,
		&i.CurrentPosition,
		&i.IsActive,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UnsubscribedAt,
		&i.PausedAt,
		&i.SequenceName,
		&i.SequenceType,
	)
	return i, err
}

const getEntryRule = `-- name: GetEntryRule :one
SELECT id, sequence_id, trigger_type, source_id, priority, is_active, created_at FROM sequence_entry_rules WHERE id = ?1
`

func (q *Queries) GetEntryRule(ctx context.Context, id string) (SequenceEntryRule, error) {
	row := q.db.QueryRowContext(ctx, getEntryRule, id)
	var i SequenceEntryRule
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.TriggerType,
		&i.SourceID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const listEntryRulesByList = `-- name: ListEntryRulesByList :many
SELECT ser.id, ser.sequence_id, ser.trigger_type, ser.source_id, ser.priority, ser.is_active, ser.created_at, es.name as sequence_name, es.slug as sequence_slug
FROM sequence_entry_rules ser
JOIN email_sequences es ON es.id = ser.sequence_id
WHERE ser.trigger_type = 'list_join' AND ser.source_id = ?1 AND ser.is_active = 1
ORDER BY ser.priority
`

type ListEntryRulesByListRow struct {
	ID           string         `json:"id"`
	SequenceID   string         `json:"sequence_id"`
	TriggerType  string         `json:"trigger_type"`
	SourceID     string         `json:"source_id"`
	Priority     sql.NullInt64  `json:"priority"`
	IsActive     sql.NullInt64  `json:"is_active"`
	CreatedAt    sql.NullString `json:"created_at"`
	SequenceName string         `json:"sequence_name"`
	SequenceSlug string         `json:"sequence_slug"`
}

func (q *Queries) ListEntryRulesByList(ctx context.Context, sourceID string) ([]ListEntryRulesByListRow, error) {
	rows, err := q.db.QueryContext(ctx, listEntryRulesByList, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntryRulesByListRow
	for rows.Next() {
		var i ListEntryRulesByListRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceID,
			&i.TriggerType,
			&i.SourceID,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.SequenceName,
			&i.SequenceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntryRulesBySequence = `-- name: ListEntryRulesBySequence :many
SELECT ser.id, ser.sequence_id, ser.trigger_type, ser.source_id, ser.priority, ser.is_active, ser.created_at, el.name as list_name, el.slug as list_slug,
       es2.name as source_sequence_name
FROM sequence_entry_rules ser
LEFT JOIN email_lists el ON ser.trigger_type = 'list_join' AND el.id = ser.source_id
LEFT JOIN email_sequences es2 ON ser.trigger_type = 'sequence_complete' AND es2.id = ser.source_id
WHERE ser.sequence_id = ?1
ORDER BY ser.priority, ser.created_at
`

type ListEntryRulesBySequenceRow struct {
	ID                 string         `json:"id"`
	SequenceID         string         `json:"sequence_id"`
	TriggerType        string         `json:"trigger_type"`
	SourceID           string         `json:"source_id"`
	Priority           sql.NullInt64  `json:"priority"`
	IsActive           sql.NullInt64  `json:"is_active"`
	CreatedAt          sql.NullString `json:"created_at"`
	ListName           sql.NullString `json:"list_name"`
	ListSlug           sql.NullString `json:"list_slug"`
	SourceSequenceName sql.NullString `json:"source_sequence_name"`
}

func (q *Queries) ListEntryRulesBySequence(ctx context.Context, sequenceID string) ([]ListEntryRulesBySequenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listEntryRulesBySequence, sequenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntryRulesBySequenceRow
	for rows.Next() {
		var i ListEntryRulesBySequenceRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceID,
			&i.TriggerType,
			&i.SourceID,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.ListName,
			&i.ListSlug,
			&i.SourceSequenceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntryRule = `-- name: UpdateEntryRule :exec
UPDATE sequence_entry_rules
SET priority = ?1, is_active = ?2
WHERE id = ?3
`

type UpdateEntryRuleParams struct {
	Priority sql.NullInt64 `json:"priority"`
	IsActive sql.NullInt64 `json:"is_active"`
	ID       string        `json:"id"`
}

func (q *Queries) UpdateEntryRule(ctx context.Context, arg UpdateEntryRuleParams) error {
	_, err := q.db.ExecContext(ctx, updateEntryRule, arg.Priority, arg.IsActive, arg.ID)
	return err
}
