// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rules.sql

package db

import (
	"context"
	"database/sql"
)

const checkEventProcessed = `-- name: CheckEventProcessed :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM automation_log WHERE org_id = ?1 AND event_id = ?2 AND rule_id = ?3
`

type CheckEventProcessedParams struct {
	OrgID   string         `json:"org_id"`
	EventID string         `json:"event_id"`
	RuleID  sql.NullString `json:"rule_id"`
}

// Check if an event has already been processed by a rule
func (q *Queries) CheckEventProcessed(ctx context.Context, arg CheckEventProcessedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkEventProcessed, arg.OrgID, arg.EventID, arg.RuleID)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const countAutomationLog = `-- name: CountAutomationLog :one
SELECT COUNT(*) as count FROM automation_log
WHERE org_id = ?1
  AND (?2 IS NULL OR ?2 = '' OR event_type = ?2)
  AND (?3 IS NULL OR ?3 = '' OR rule_id = ?3)
  AND (?4 IS NULL OR ?4 = '' OR success = (?4 = '1'))
`

type CountAutomationLogParams struct {
	OrgID           string      `json:"org_id"`
	FilterEventType interface{} `json:"filter_event_type"`
	FilterRuleID    interface{} `json:"filter_rule_id"`
	FilterSuccess   interface{} `json:"filter_success"`
}

// Count automation log entries with optional filters
func (q *Queries) CountAutomationLog(ctx context.Context, arg CountAutomationLogParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAutomationLog,
		arg.OrgID,
		arg.FilterEventType,
		arg.FilterRuleID,
		arg.FilterSuccess,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrgRules = `-- name: CountOrgRules :one
SELECT COUNT(*) as count FROM org_rules
WHERE org_id = ?1
  AND (?2 IS NULL OR ?2 = '' OR category = ?2)
  AND (?3 IS NULL OR ?3 = '' OR enabled = (?3 = '1'))
`

type CountOrgRulesParams struct {
	OrgID          string      `json:"org_id"`
	FilterCategory interface{} `json:"filter_category"`
	FilterEnabled  interface{} `json:"filter_enabled"`
}

// Count rules with optional filters
func (q *Queries) CountOrgRules(ctx context.Context, arg CountOrgRulesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrgRules, arg.OrgID, arg.FilterCategory, arg.FilterEnabled)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrgRule = `-- name: CreateOrgRule :one
INSERT INTO org_rules (
    id, org_id, name, description, category, rule_json,
    entity_type, entity_id, enabled, salience,
    compiled_hash, validation_errors, last_validated_at,
    created_by, created_at, updated_at
)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, datetime('now'), datetime('now'))
RETURNING id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at
`

type CreateOrgRuleParams struct {
	ID               string         `json:"id"`
	OrgID            string         `json:"org_id"`
	Name             string         `json:"name"`
	Description      sql.NullString `json:"description"`
	Category         string         `json:"category"`
	RuleJson         string         `json:"rule_json"`
	EntityType       sql.NullString `json:"entity_type"`
	EntityID         sql.NullString `json:"entity_id"`
	Enabled          sql.NullInt64  `json:"enabled"`
	Salience         sql.NullInt64  `json:"salience"`
	CompiledHash     sql.NullString `json:"compiled_hash"`
	ValidationErrors sql.NullString `json:"validation_errors"`
	LastValidatedAt  sql.NullString `json:"last_validated_at"`
	CreatedBy        sql.NullString `json:"created_by"`
}

// Create a new rule
func (q *Queries) CreateOrgRule(ctx context.Context, arg CreateOrgRuleParams) (OrgRule, error) {
	row := q.db.QueryRowContext(ctx, createOrgRule,
		arg.ID,
		arg.OrgID,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.RuleJson,
		arg.EntityType,
		arg.EntityID,
		arg.Enabled,
		arg.Salience,
		arg.CompiledHash,
		arg.ValidationErrors,
		arg.LastValidatedAt,
		arg.CreatedBy,
	)
	var i OrgRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.EntityType,
		&i.EntityID,
		&i.Enabled,
		&i.Salience,
		&i.CompiledHash,
		&i.ValidationErrors,
		&i.LastValidatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRuleTemplate = `-- name: CreateRuleTemplate :one
INSERT INTO rule_templates (id, name, description, category, rule_json, configurable_params, is_recommended, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, datetime('now'))
RETURNING id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at
`

type CreateRuleTemplateParams struct {
	ID                 string         `json:"id"`
	Name               string         `json:"name"`
	Description        sql.NullString `json:"description"`
	Category           string         `json:"category"`
	RuleJson           string         `json:"rule_json"`
	ConfigurableParams sql.NullString `json:"configurable_params"`
	IsRecommended      sql.NullInt64  `json:"is_recommended"`
}

// Create a new rule template (platform admin only)
func (q *Queries) CreateRuleTemplate(ctx context.Context, arg CreateRuleTemplateParams) (RuleTemplate, error) {
	row := q.db.QueryRowContext(ctx, createRuleTemplate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.RuleJson,
		arg.ConfigurableParams,
		arg.IsRecommended,
	)
	var i RuleTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.ConfigurableParams,
		&i.IsRecommended,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrgRule = `-- name: DeleteOrgRule :exec
DELETE FROM org_rules WHERE id = ?1 AND org_id = ?2
`

type DeleteOrgRuleParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

// Delete a rule
func (q *Queries) DeleteOrgRule(ctx context.Context, arg DeleteOrgRuleParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrgRule, arg.ID, arg.OrgID)
	return err
}

const deleteRuleTemplate = `-- name: DeleteRuleTemplate :exec
DELETE FROM rule_templates WHERE id = ?1
`

// Delete a rule template
func (q *Queries) DeleteRuleTemplate(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteRuleTemplate, id)
	return err
}

const getAllOrgRules = `-- name: GetAllOrgRules :many
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1
ORDER BY category, salience DESC, name
`

// Get all rules for an organization (including disabled), for admin listing
func (q *Queries) GetAllOrgRules(ctx context.Context, orgID string) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrgRules, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationLog = `-- name: GetAutomationLog :many
SELECT id, org_id, event_id, event_type, event_payload, rule_id, rule_name, rule_snapshot, actions_executed, success, error_message, execution_time_ms, created_at FROM automation_log
WHERE org_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type GetAutomationLogParams struct {
	OrgID      string `json:"org_id"`
	PageOffset int64  `json:"page_offset"`
	PageSize   int64  `json:"page_size"`
}

// Get recent automation log entries for an organization
func (q *Queries) GetAutomationLog(ctx context.Context, arg GetAutomationLogParams) ([]AutomationLog, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationLog, arg.OrgID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutomationLog
	for rows.Next() {
		var i AutomationLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EventID,
			&i.EventType,
			&i.EventPayload,
			&i.RuleID,
			&i.RuleName,
			&i.RuleSnapshot,
			&i.ActionsExecuted,
			&i.Success,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationLogByRule = `-- name: GetAutomationLogByRule :many
SELECT id, org_id, event_id, event_type, event_payload, rule_id, rule_name, rule_snapshot, actions_executed, success, error_message, execution_time_ms, created_at FROM automation_log
WHERE rule_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type GetAutomationLogByRuleParams struct {
	RuleID     sql.NullString `json:"rule_id"`
	PageOffset int64          `json:"page_offset"`
	PageSize   int64          `json:"page_size"`
}

// Get automation log entries for a specific rule
func (q *Queries) GetAutomationLogByRule(ctx context.Context, arg GetAutomationLogByRuleParams) ([]AutomationLog, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationLogByRule, arg.RuleID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutomationLog
	for rows.Next() {
		var i AutomationLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EventID,
			&i.EventType,
			&i.EventPayload,
			&i.RuleID,
			&i.RuleName,
			&i.RuleSnapshot,
			&i.ActionsExecuted,
			&i.Success,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationLogFiltered = `-- name: GetAutomationLogFiltered :many
SELECT id, org_id, event_id, event_type, event_payload, rule_id, rule_name, rule_snapshot, actions_executed, success, error_message, execution_time_ms, created_at FROM automation_log
WHERE org_id = ?1
  AND (?2 IS NULL OR ?2 = '' OR event_type = ?2)
  AND (?3 IS NULL OR ?3 = '' OR rule_id = ?3)
  AND (?4 IS NULL OR ?4 = '' OR success = (?4 = '1'))
ORDER BY created_at DESC
LIMIT ?6 OFFSET ?5
`

type GetAutomationLogFilteredParams struct {
	OrgID           string      `json:"org_id"`
	FilterEventType interface{} `json:"filter_event_type"`
	FilterRuleID    interface{} `json:"filter_rule_id"`
	FilterSuccess   interface{} `json:"filter_success"`
	PageOffset      int64       `json:"page_offset"`
	PageSize        int64       `json:"page_size"`
}

// Get automation log with filters
func (q *Queries) GetAutomationLogFiltered(ctx context.Context, arg GetAutomationLogFilteredParams) ([]AutomationLog, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationLogFiltered,
		arg.OrgID,
		arg.FilterEventType,
		arg.FilterRuleID,
		arg.FilterSuccess,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutomationLog
	for rows.Next() {
		var i AutomationLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EventID,
			&i.EventType,
			&i.EventPayload,
			&i.RuleID,
			&i.RuleName,
			&i.RuleSnapshot,
			&i.ActionsExecuted,
			&i.Success,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationLogStats = `-- name: GetAutomationLogStats :one
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful,
    SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failed,
    AVG(execution_time_ms) as avg_execution_time_ms
FROM automation_log
WHERE org_id = ?1
  AND created_at > datetime('now', '-24 hours')
`

type GetAutomationLogStatsRow struct {
	Total              int64           `json:"total"`
	Successful         sql.NullFloat64 `json:"successful"`
	Failed             sql.NullFloat64 `json:"failed"`
	AvgExecutionTimeMs sql.NullFloat64 `json:"avg_execution_time_ms"`
}

// Get stats for automation log (for dashboard)
func (q *Queries) GetAutomationLogStats(ctx context.Context, orgID string) (GetAutomationLogStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAutomationLogStats, orgID)
	var i GetAutomationLogStatsRow
	err := row.Scan(
		&i.Total,
		&i.Successful,
		&i.Failed,
		&i.AvgExecutionTimeMs,
	)
	return i, err
}

const getDefaultRuleTemplates = `-- name: GetDefaultRuleTemplates :many
SELECT id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at FROM rule_templates
WHERE is_default = 1
ORDER BY category, name
`

// Get all rule templates marked as defaults
func (q *Queries) GetDefaultRuleTemplates(ctx context.Context) ([]RuleTemplate, error) {
	rows, err := q.db.QueryContext(ctx, getDefaultRuleTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RuleTemplate
	for rows.Next() {
		var i RuleTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.ConfigurableParams,
			&i.IsRecommended,
			&i.IsDefault,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityRules = `-- name: GetEntityRules :many
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1 AND entity_type = ?2 AND entity_id = ?3 AND enabled = 1
ORDER BY salience DESC
`

type GetEntityRulesParams struct {
	OrgID      string         `json:"org_id"`
	EntityType sql.NullString `json:"entity_type"`
	EntityID   sql.NullString `json:"entity_id"`
}

// Get enabled rules for a specific entity (e.g., email_list, product)
func (q *Queries) GetEntityRules(ctx context.Context, arg GetEntityRulesParams) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getEntityRules, arg.OrgID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgRuleById = `-- name: GetOrgRuleById :one
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE id = ?1 AND org_id = ?2
`

type GetOrgRuleByIdParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

// Get a single rule by ID
func (q *Queries) GetOrgRuleById(ctx context.Context, arg GetOrgRuleByIdParams) (OrgRule, error) {
	row := q.db.QueryRowContext(ctx, getOrgRuleById, arg.ID, arg.OrgID)
	var i OrgRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.EntityType,
		&i.EntityID,
		&i.Enabled,
		&i.Salience,
		&i.CompiledHash,
		&i.ValidationErrors,
		&i.LastValidatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrgRules = `-- name: GetOrgRules :many

SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1 AND enabled = 1
ORDER BY salience DESC, created_at
`

// =====================================================
// Org Rules
// =====================================================
// Get all enabled rules for an organization, ordered by salience
func (q *Queries) GetOrgRules(ctx context.Context, orgID string) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getOrgRules, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgRulesByCategory = `-- name: GetOrgRulesByCategory :many
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1 AND category = ?2 AND enabled = 1
ORDER BY salience DESC
`

type GetOrgRulesByCategoryParams struct {
	OrgID    string `json:"org_id"`
	Category string `json:"category"`
}

// Get enabled rules for an organization filtered by category
func (q *Queries) GetOrgRulesByCategory(ctx context.Context, arg GetOrgRulesByCategoryParams) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getOrgRulesByCategory, arg.OrgID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgRulesFiltered = `-- name: GetOrgRulesFiltered :many
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1
  AND (?2 IS NULL OR ?2 = '' OR category = ?2)
  AND (?3 IS NULL OR ?3 = '' OR enabled = (?3 = '1'))
ORDER BY category, salience DESC, name
LIMIT ?5 OFFSET ?4
`

type GetOrgRulesFilteredParams struct {
	OrgID          string      `json:"org_id"`
	FilterCategory interface{} `json:"filter_category"`
	FilterEnabled  interface{} `json:"filter_enabled"`
	PageOffset     int64       `json:"page_offset"`
	PageSize       int64       `json:"page_size"`
}

// Get rules with optional category and enabled filters
func (q *Queries) GetOrgRulesFiltered(ctx context.Context, arg GetOrgRulesFilteredParams) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getOrgRulesFiltered,
		arg.OrgID,
		arg.FilterCategory,
		arg.FilterEnabled,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRuleTemplateById = `-- name: GetRuleTemplateById :one
SELECT id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at FROM rule_templates
WHERE id = ?1
`

// Get a single rule template by ID
func (q *Queries) GetRuleTemplateById(ctx context.Context, id string) (RuleTemplate, error) {
	row := q.db.QueryRowContext(ctx, getRuleTemplateById, id)
	var i RuleTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.ConfigurableParams,
		&i.IsRecommended,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const getRuleTemplates = `-- name: GetRuleTemplates :many

SELECT id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at FROM rule_templates
ORDER BY is_recommended DESC, category, name
`

// =====================================================
// Rule Templates
// =====================================================
// Get all rule templates
func (q *Queries) GetRuleTemplates(ctx context.Context) ([]RuleTemplate, error) {
	rows, err := q.db.QueryContext(ctx, getRuleTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RuleTemplate
	for rows.Next() {
		var i RuleTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.ConfigurableParams,
			&i.IsRecommended,
			&i.IsDefault,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRuleTemplatesByCategory = `-- name: GetRuleTemplatesByCategory :many
SELECT id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at FROM rule_templates
WHERE category = ?1
ORDER BY is_recommended DESC, name
`

// Get rule templates filtered by category
func (q *Queries) GetRuleTemplatesByCategory(ctx context.Context, category string) ([]RuleTemplate, error) {
	rows, err := q.db.QueryContext(ctx, getRuleTemplatesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RuleTemplate
	for rows.Next() {
		var i RuleTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.ConfigurableParams,
			&i.IsRecommended,
			&i.IsDefault,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRulesWithStaleValidation = `-- name: GetRulesWithStaleValidation :many
SELECT id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at FROM org_rules
WHERE org_id = ?1 AND enabled = 1
  AND (compiled_hash IS NULL OR last_validated_at < updated_at)
`

// Get rules that need revalidation (hash doesn't match content)
func (q *Queries) GetRulesWithStaleValidation(ctx context.Context, orgID string) ([]OrgRule, error) {
	rows, err := q.db.QueryContext(ctx, getRulesWithStaleValidation, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgRule
	for rows.Next() {
		var i OrgRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.RuleJson,
			&i.EntityType,
			&i.EntityID,
			&i.Enabled,
			&i.Salience,
			&i.CompiledHash,
			&i.ValidationErrors,
			&i.LastValidatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAutomation = `-- name: LogAutomation :one

INSERT INTO automation_log (
    id, org_id, event_id, event_type, event_payload,
    rule_id, rule_name, rule_snapshot,
    actions_executed, success, error_message, execution_time_ms, created_at
)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, datetime('now'))
ON CONFLICT (org_id, event_id, rule_id) DO NOTHING
RETURNING id, org_id, event_id, event_type, event_payload, rule_id, rule_name, rule_snapshot, actions_executed, success, error_message, execution_time_ms, created_at
`

type LogAutomationParams struct {
	ID              string         `json:"id"`
	OrgID           string         `json:"org_id"`
	EventID         string         `json:"event_id"`
	EventType       string         `json:"event_type"`
	EventPayload    sql.NullString `json:"event_payload"`
	RuleID          sql.NullString `json:"rule_id"`
	RuleName        string         `json:"rule_name"`
	RuleSnapshot    sql.NullString `json:"rule_snapshot"`
	ActionsExecuted sql.NullString `json:"actions_executed"`
	Success         int64          `json:"success"`
	ErrorMessage    sql.NullString `json:"error_message"`
	ExecutionTimeMs sql.NullInt64  `json:"execution_time_ms"`
}

// =====================================================
// Automation Log
// =====================================================
// Log a rule execution (idempotent - skips if already processed)
func (q *Queries) LogAutomation(ctx context.Context, arg LogAutomationParams) (AutomationLog, error) {
	row := q.db.QueryRowContext(ctx, logAutomation,
		arg.ID,
		arg.OrgID,
		arg.EventID,
		arg.EventType,
		arg.EventPayload,
		arg.RuleID,
		arg.RuleName,
		arg.RuleSnapshot,
		arg.ActionsExecuted,
		arg.Success,
		arg.ErrorMessage,
		arg.ExecutionTimeMs,
	)
	var i AutomationLog
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.EventID,
		&i.EventType,
		&i.EventPayload,
		&i.RuleID,
		&i.RuleName,
		&i.RuleSnapshot,
		&i.ActionsExecuted,
		&i.Success,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
	)
	return i, err
}

const toggleOrgRule = `-- name: ToggleOrgRule :one
UPDATE org_rules
SET enabled = CASE WHEN enabled = 1 THEN 0 ELSE 1 END,
    updated_by = ?1,
    updated_at = datetime('now')
WHERE id = ?2
RETURNING id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at
`

type ToggleOrgRuleParams struct {
	UpdatedBy sql.NullString `json:"updated_by"`
	ID        string         `json:"id"`
}

// Toggle enabled state of a rule
func (q *Queries) ToggleOrgRule(ctx context.Context, arg ToggleOrgRuleParams) (OrgRule, error) {
	row := q.db.QueryRowContext(ctx, toggleOrgRule, arg.UpdatedBy, arg.ID)
	var i OrgRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.EntityType,
		&i.EntityID,
		&i.Enabled,
		&i.Salience,
		&i.CompiledHash,
		&i.ValidationErrors,
		&i.LastValidatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrgRule = `-- name: UpdateOrgRule :one
UPDATE org_rules
SET name = ?1,
    description = ?2,
    rule_json = ?3,
    entity_type = ?4,
    entity_id = ?5,
    enabled = ?6,
    salience = ?7,
    compiled_hash = ?8,
    validation_errors = ?9,
    last_validated_at = ?10,
    updated_by = ?11,
    updated_at = datetime('now')
WHERE id = ?12
RETURNING id, org_id, name, description, category, rule_json, entity_type, entity_id, enabled, salience, compiled_hash, validation_errors, last_validated_at, created_by, updated_by, created_at, updated_at
`

type UpdateOrgRuleParams struct {
	Name             string         `json:"name"`
	Description      sql.NullString `json:"description"`
	RuleJson         string         `json:"rule_json"`
	EntityType       sql.NullString `json:"entity_type"`
	EntityID         sql.NullString `json:"entity_id"`
	Enabled          sql.NullInt64  `json:"enabled"`
	Salience         sql.NullInt64  `json:"salience"`
	CompiledHash     sql.NullString `json:"compiled_hash"`
	ValidationErrors sql.NullString `json:"validation_errors"`
	LastValidatedAt  sql.NullString `json:"last_validated_at"`
	UpdatedBy        sql.NullString `json:"updated_by"`
	ID               string         `json:"id"`
}

// Update an existing rule
func (q *Queries) UpdateOrgRule(ctx context.Context, arg UpdateOrgRuleParams) (OrgRule, error) {
	row := q.db.QueryRowContext(ctx, updateOrgRule,
		arg.Name,
		arg.Description,
		arg.RuleJson,
		arg.EntityType,
		arg.EntityID,
		arg.Enabled,
		arg.Salience,
		arg.CompiledHash,
		arg.ValidationErrors,
		arg.LastValidatedAt,
		arg.UpdatedBy,
		arg.ID,
	)
	var i OrgRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.EntityType,
		&i.EntityID,
		&i.Enabled,
		&i.Salience,
		&i.CompiledHash,
		&i.ValidationErrors,
		&i.LastValidatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRuleTemplate = `-- name: UpdateRuleTemplate :one
UPDATE rule_templates
SET name = ?1,
    description = ?2,
    category = ?3,
    rule_json = ?4,
    configurable_params = ?5,
    is_recommended = ?6
WHERE id = ?7
RETURNING id, name, description, category, rule_json, configurable_params, is_recommended, is_default, created_at
`

type UpdateRuleTemplateParams struct {
	Name               string         `json:"name"`
	Description        sql.NullString `json:"description"`
	Category           string         `json:"category"`
	RuleJson           string         `json:"rule_json"`
	ConfigurableParams sql.NullString `json:"configurable_params"`
	IsRecommended      sql.NullInt64  `json:"is_recommended"`
	ID                 string         `json:"id"`
}

// Update a rule template
func (q *Queries) UpdateRuleTemplate(ctx context.Context, arg UpdateRuleTemplateParams) (RuleTemplate, error) {
	row := q.db.QueryRowContext(ctx, updateRuleTemplate,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.RuleJson,
		arg.ConfigurableParams,
		arg.IsRecommended,
		arg.ID,
	)
	var i RuleTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.RuleJson,
		&i.ConfigurableParams,
		&i.IsRecommended,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const updateRuleValidation = `-- name: UpdateRuleValidation :exec
UPDATE org_rules
SET compiled_hash = ?1,
    validation_errors = ?2,
    last_validated_at = datetime('now')
WHERE id = ?3
`

type UpdateRuleValidationParams struct {
	CompiledHash     sql.NullString `json:"compiled_hash"`
	ValidationErrors sql.NullString `json:"validation_errors"`
	ID               string         `json:"id"`
}

// Update just the validation fields (after recompiling)
func (q *Queries) UpdateRuleValidation(ctx context.Context, arg UpdateRuleValidationParams) error {
	_, err := q.db.ExecContext(ctx, updateRuleValidation, arg.CompiledHash, arg.ValidationErrors, arg.ID)
	return err
}
