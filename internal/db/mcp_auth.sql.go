// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mcp_auth.sql

package db

import (
	"context"
	"database/sql"
)

const cleanupExpiredMCPOAuthCodes = `-- name: CleanupExpiredMCPOAuthCodes :exec
DELETE FROM mcp_oauth_codes
WHERE expires_at < datetime('now') OR used_at IS NOT NULL
`

func (q *Queries) CleanupExpiredMCPOAuthCodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredMCPOAuthCodes)
	return err
}

const cleanupExpiredMCPOAuthTokens = `-- name: CleanupExpiredMCPOAuthTokens :exec
DELETE FROM mcp_oauth_tokens
WHERE (expires_at < datetime('now') AND (refresh_expires_at IS NULL OR refresh_expires_at < datetime('now')))
   OR revoked_at < datetime('now', '-30 days')
`

func (q *Queries) CleanupExpiredMCPOAuthTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredMCPOAuthTokens)
	return err
}

const cleanupOldMCPSessions = `-- name: CleanupOldMCPSessions :exec
DELETE FROM mcp_sessions
WHERE updated_at < datetime('now', '-30 days')
`

// Delete sessions older than 30 days
func (q *Queries) CleanupOldMCPSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldMCPSessions)
	return err
}

const createMCPAPIKey = `-- name: CreateMCPAPIKey :one

INSERT INTO mcp_api_keys (id, user_id, name, key_hash, key_prefix, scopes, expires_at, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, datetime('now'), datetime('now'))
RETURNING id, user_id, name, key_hash, key_prefix, scopes, last_used_at, expires_at, revoked_at, created_at, updated_at
`

type CreateMCPAPIKeyParams struct {
	ID        string         `json:"id"`
	UserID    string         `json:"user_id"`
	Name      string         `json:"name"`
	KeyHash   string         `json:"key_hash"`
	KeyPrefix string         `json:"key_prefix"`
	Scopes    sql.NullString `json:"scopes"`
	ExpiresAt sql.NullString `json:"expires_at"`
}

// MCP API Keys
func (q *Queries) CreateMCPAPIKey(ctx context.Context, arg CreateMCPAPIKeyParams) (McpApiKey, error) {
	row := q.db.QueryRowContext(ctx, createMCPAPIKey,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.KeyHash,
		arg.KeyPrefix,
		arg.Scopes,
		arg.ExpiresAt,
	)
	var i McpApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMCPOAuthClient = `-- name: CreateMCPOAuthClient :one

INSERT INTO mcp_oauth_clients (id, client_id, client_secret_hash, name, description, redirect_uris, scopes, is_confidential, is_active, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 1, datetime('now'), datetime('now'))
RETURNING id, client_id, client_secret_hash, name, description, redirect_uris, scopes, is_confidential, is_active, created_at, updated_at
`

type CreateMCPOAuthClientParams struct {
	ID               string         `json:"id"`
	ClientID         string         `json:"client_id"`
	ClientSecretHash string         `json:"client_secret_hash"`
	Name             string         `json:"name"`
	Description      sql.NullString `json:"description"`
	RedirectUris     string         `json:"redirect_uris"`
	Scopes           sql.NullString `json:"scopes"`
	IsConfidential   sql.NullInt64  `json:"is_confidential"`
}

// MCP OAuth Clients
func (q *Queries) CreateMCPOAuthClient(ctx context.Context, arg CreateMCPOAuthClientParams) (McpOauthClient, error) {
	row := q.db.QueryRowContext(ctx, createMCPOAuthClient,
		arg.ID,
		arg.ClientID,
		arg.ClientSecretHash,
		arg.Name,
		arg.Description,
		arg.RedirectUris,
		arg.Scopes,
		arg.IsConfidential,
	)
	var i McpOauthClient
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecretHash,
		&i.Name,
		&i.Description,
		&i.RedirectUris,
		&i.Scopes,
		&i.IsConfidential,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMCPOAuthCode = `-- name: CreateMCPOAuthCode :one

INSERT INTO mcp_oauth_codes (id, client_id, user_id, code_hash, redirect_uri, scopes, code_challenge, code_challenge_method, expires_at, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, datetime('now'))
RETURNING id, client_id, user_id, code_hash, redirect_uri, scopes, code_challenge, code_challenge_method, expires_at, used_at, created_at
`

type CreateMCPOAuthCodeParams struct {
	ID                  string         `json:"id"`
	ClientID            string         `json:"client_id"`
	UserID              string         `json:"user_id"`
	CodeHash            string         `json:"code_hash"`
	RedirectUri         string         `json:"redirect_uri"`
	Scopes              string         `json:"scopes"`
	CodeChallenge       sql.NullString `json:"code_challenge"`
	CodeChallengeMethod sql.NullString `json:"code_challenge_method"`
	ExpiresAt           string         `json:"expires_at"`
}

// MCP OAuth Authorization Codes
func (q *Queries) CreateMCPOAuthCode(ctx context.Context, arg CreateMCPOAuthCodeParams) (McpOauthCode, error) {
	row := q.db.QueryRowContext(ctx, createMCPOAuthCode,
		arg.ID,
		arg.ClientID,
		arg.UserID,
		arg.CodeHash,
		arg.RedirectUri,
		arg.Scopes,
		arg.CodeChallenge,
		arg.CodeChallengeMethod,
		arg.ExpiresAt,
	)
	var i McpOauthCode
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.CodeHash,
		&i.RedirectUri,
		&i.Scopes,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createMCPOAuthToken = `-- name: CreateMCPOAuthToken :one

INSERT INTO mcp_oauth_tokens (id, client_id, user_id, access_token_hash, refresh_token_hash, scopes, expires_at, refresh_expires_at, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, datetime('now'), datetime('now'))
RETURNING id, client_id, user_id, access_token_hash, refresh_token_hash, scopes, expires_at, refresh_expires_at, revoked_at, created_at, updated_at
`

type CreateMCPOAuthTokenParams struct {
	ID               string         `json:"id"`
	ClientID         string         `json:"client_id"`
	UserID           string         `json:"user_id"`
	AccessTokenHash  string         `json:"access_token_hash"`
	RefreshTokenHash sql.NullString `json:"refresh_token_hash"`
	Scopes           string         `json:"scopes"`
	ExpiresAt        string         `json:"expires_at"`
	RefreshExpiresAt sql.NullString `json:"refresh_expires_at"`
}

// MCP OAuth Tokens
func (q *Queries) CreateMCPOAuthToken(ctx context.Context, arg CreateMCPOAuthTokenParams) (McpOauthToken, error) {
	row := q.db.QueryRowContext(ctx, createMCPOAuthToken,
		arg.ID,
		arg.ClientID,
		arg.UserID,
		arg.AccessTokenHash,
		arg.RefreshTokenHash,
		arg.Scopes,
		arg.ExpiresAt,
		arg.RefreshExpiresAt,
	)
	var i McpOauthToken
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.AccessTokenHash,
		&i.RefreshTokenHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateMCPOAuthClient = `-- name: DeactivateMCPOAuthClient :exec
UPDATE mcp_oauth_clients
SET is_active = 0, updated_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) DeactivateMCPOAuthClient(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deactivateMCPOAuthClient, id)
	return err
}

const deleteMCPAPIKey = `-- name: DeleteMCPAPIKey :exec
DELETE FROM mcp_api_keys WHERE id = ?1
`

func (q *Queries) DeleteMCPAPIKey(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMCPAPIKey, id)
	return err
}

const deleteMCPSession = `-- name: DeleteMCPSession :exec
DELETE FROM mcp_sessions WHERE session_id = ?1
`

func (q *Queries) DeleteMCPSession(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteMCPSession, sessionID)
	return err
}

const getMCPAPIKeyByHash = `-- name: GetMCPAPIKeyByHash :one
SELECT k.id, k.user_id, k.name, k.key_hash, k.key_prefix, k.scopes, k.last_used_at, k.expires_at, k.revoked_at, k.created_at, k.updated_at, u.email as user_email, u.name as user_name, u.role as user_role, u.status as user_status
FROM mcp_api_keys k
JOIN users u ON k.user_id = u.id
WHERE k.key_hash = ?1
  AND k.revoked_at IS NULL
  AND (k.expires_at IS NULL OR k.expires_at > datetime('now'))
`

type GetMCPAPIKeyByHashRow struct {
	ID         string         `json:"id"`
	UserID     string         `json:"user_id"`
	Name       string         `json:"name"`
	KeyHash    string         `json:"key_hash"`
	KeyPrefix  string         `json:"key_prefix"`
	Scopes     sql.NullString `json:"scopes"`
	LastUsedAt sql.NullString `json:"last_used_at"`
	ExpiresAt  sql.NullString `json:"expires_at"`
	RevokedAt  sql.NullString `json:"revoked_at"`
	CreatedAt  sql.NullString `json:"created_at"`
	UpdatedAt  sql.NullString `json:"updated_at"`
	UserEmail  string         `json:"user_email"`
	UserName   string         `json:"user_name"`
	UserRole   string         `json:"user_role"`
	UserStatus string         `json:"user_status"`
}

func (q *Queries) GetMCPAPIKeyByHash(ctx context.Context, keyHash string) (GetMCPAPIKeyByHashRow, error) {
	row := q.db.QueryRowContext(ctx, getMCPAPIKeyByHash, keyHash)
	var i GetMCPAPIKeyByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserEmail,
		&i.UserName,
		&i.UserRole,
		&i.UserStatus,
	)
	return i, err
}

const getMCPAPIKeyByPrefix = `-- name: GetMCPAPIKeyByPrefix :many
SELECT id, user_id, name, key_hash, key_prefix, scopes, last_used_at, expires_at, revoked_at, created_at, updated_at FROM mcp_api_keys
WHERE key_prefix = ?1
  AND revoked_at IS NULL
`

func (q *Queries) GetMCPAPIKeyByPrefix(ctx context.Context, keyPrefix string) ([]McpApiKey, error) {
	rows, err := q.db.QueryContext(ctx, getMCPAPIKeyByPrefix, keyPrefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McpApiKey
	for rows.Next() {
		var i McpApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.KeyHash,
			&i.KeyPrefix,
			&i.Scopes,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMCPOAuthClientByClientID = `-- name: GetMCPOAuthClientByClientID :one
SELECT id, client_id, client_secret_hash, name, description, redirect_uris, scopes, is_confidential, is_active, created_at, updated_at FROM mcp_oauth_clients
WHERE client_id = ?1 AND is_active = 1
`

func (q *Queries) GetMCPOAuthClientByClientID(ctx context.Context, clientID string) (McpOauthClient, error) {
	row := q.db.QueryRowContext(ctx, getMCPOAuthClientByClientID, clientID)
	var i McpOauthClient
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecretHash,
		&i.Name,
		&i.Description,
		&i.RedirectUris,
		&i.Scopes,
		&i.IsConfidential,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMCPOAuthCodeByHash = `-- name: GetMCPOAuthCodeByHash :one
SELECT c.id, c.client_id, c.user_id, c.code_hash, c.redirect_uri, c.scopes, c.code_challenge, c.code_challenge_method, c.expires_at, c.used_at, c.created_at, cl.client_id as oauth_client_id, cl.name as client_name
FROM mcp_oauth_codes c
JOIN mcp_oauth_clients cl ON c.client_id = cl.id
WHERE c.code_hash = ?1
  AND c.used_at IS NULL
  AND c.expires_at > datetime('now')
`

type GetMCPOAuthCodeByHashRow struct {
	ID                  string         `json:"id"`
	ClientID            string         `json:"client_id"`
	UserID              string         `json:"user_id"`
	CodeHash            string         `json:"code_hash"`
	RedirectUri         string         `json:"redirect_uri"`
	Scopes              string         `json:"scopes"`
	CodeChallenge       sql.NullString `json:"code_challenge"`
	CodeChallengeMethod sql.NullString `json:"code_challenge_method"`
	ExpiresAt           string         `json:"expires_at"`
	UsedAt              sql.NullString `json:"used_at"`
	CreatedAt           sql.NullString `json:"created_at"`
	OauthClientID       string         `json:"oauth_client_id"`
	ClientName          string         `json:"client_name"`
}

func (q *Queries) GetMCPOAuthCodeByHash(ctx context.Context, codeHash string) (GetMCPOAuthCodeByHashRow, error) {
	row := q.db.QueryRowContext(ctx, getMCPOAuthCodeByHash, codeHash)
	var i GetMCPOAuthCodeByHashRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.CodeHash,
		&i.RedirectUri,
		&i.Scopes,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
		&i.OauthClientID,
		&i.ClientName,
	)
	return i, err
}

const getMCPOAuthTokenByAccessHash = `-- name: GetMCPOAuthTokenByAccessHash :one
SELECT t.id, t.client_id, t.user_id, t.access_token_hash, t.refresh_token_hash, t.scopes, t.expires_at, t.refresh_expires_at, t.revoked_at, t.created_at, t.updated_at, u.email as user_email, u.name as user_name, u.role as user_role, u.status as user_status,
       cl.client_id as oauth_client_id, cl.name as client_name
FROM mcp_oauth_tokens t
JOIN users u ON t.user_id = u.id
JOIN mcp_oauth_clients cl ON t.client_id = cl.id
WHERE t.access_token_hash = ?1
  AND t.revoked_at IS NULL
  AND t.expires_at > datetime('now')
`

type GetMCPOAuthTokenByAccessHashRow struct {
	ID               string         `json:"id"`
	ClientID         string         `json:"client_id"`
	UserID           string         `json:"user_id"`
	AccessTokenHash  string         `json:"access_token_hash"`
	RefreshTokenHash sql.NullString `json:"refresh_token_hash"`
	Scopes           string         `json:"scopes"`
	ExpiresAt        string         `json:"expires_at"`
	RefreshExpiresAt sql.NullString `json:"refresh_expires_at"`
	RevokedAt        sql.NullString `json:"revoked_at"`
	CreatedAt        sql.NullString `json:"created_at"`
	UpdatedAt        sql.NullString `json:"updated_at"`
	UserEmail        string         `json:"user_email"`
	UserName         string         `json:"user_name"`
	UserRole         string         `json:"user_role"`
	UserStatus       string         `json:"user_status"`
	OauthClientID    string         `json:"oauth_client_id"`
	ClientName       string         `json:"client_name"`
}

func (q *Queries) GetMCPOAuthTokenByAccessHash(ctx context.Context, accessTokenHash string) (GetMCPOAuthTokenByAccessHashRow, error) {
	row := q.db.QueryRowContext(ctx, getMCPOAuthTokenByAccessHash, accessTokenHash)
	var i GetMCPOAuthTokenByAccessHashRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.AccessTokenHash,
		&i.RefreshTokenHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserEmail,
		&i.UserName,
		&i.UserRole,
		&i.UserStatus,
		&i.OauthClientID,
		&i.ClientName,
	)
	return i, err
}

const getMCPOAuthTokenByRefreshHash = `-- name: GetMCPOAuthTokenByRefreshHash :one
SELECT t.id, t.client_id, t.user_id, t.access_token_hash, t.refresh_token_hash, t.scopes, t.expires_at, t.refresh_expires_at, t.revoked_at, t.created_at, t.updated_at, u.email as user_email, u.name as user_name, u.role as user_role, u.status as user_status,
       cl.client_id as oauth_client_id, cl.name as client_name
FROM mcp_oauth_tokens t
JOIN users u ON t.user_id = u.id
JOIN mcp_oauth_clients cl ON t.client_id = cl.id
WHERE t.refresh_token_hash = ?1
  AND t.revoked_at IS NULL
  AND (t.refresh_expires_at IS NULL OR t.refresh_expires_at > datetime('now'))
`

type GetMCPOAuthTokenByRefreshHashRow struct {
	ID               string         `json:"id"`
	ClientID         string         `json:"client_id"`
	UserID           string         `json:"user_id"`
	AccessTokenHash  string         `json:"access_token_hash"`
	RefreshTokenHash sql.NullString `json:"refresh_token_hash"`
	Scopes           string         `json:"scopes"`
	ExpiresAt        string         `json:"expires_at"`
	RefreshExpiresAt sql.NullString `json:"refresh_expires_at"`
	RevokedAt        sql.NullString `json:"revoked_at"`
	CreatedAt        sql.NullString `json:"created_at"`
	UpdatedAt        sql.NullString `json:"updated_at"`
	UserEmail        string         `json:"user_email"`
	UserName         string         `json:"user_name"`
	UserRole         string         `json:"user_role"`
	UserStatus       string         `json:"user_status"`
	OauthClientID    string         `json:"oauth_client_id"`
	ClientName       string         `json:"client_name"`
}

func (q *Queries) GetMCPOAuthTokenByRefreshHash(ctx context.Context, refreshTokenHash sql.NullString) (GetMCPOAuthTokenByRefreshHashRow, error) {
	row := q.db.QueryRowContext(ctx, getMCPOAuthTokenByRefreshHash, refreshTokenHash)
	var i GetMCPOAuthTokenByRefreshHashRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.AccessTokenHash,
		&i.RefreshTokenHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserEmail,
		&i.UserName,
		&i.UserRole,
		&i.UserStatus,
		&i.OauthClientID,
		&i.ClientName,
	)
	return i, err
}

const getMCPSession = `-- name: GetMCPSession :one
SELECT session_id, user_id, org_id, created_at, updated_at FROM mcp_sessions
WHERE session_id = ?1
`

func (q *Queries) GetMCPSession(ctx context.Context, sessionID string) (McpSession, error) {
	row := q.db.QueryRowContext(ctx, getMCPSession, sessionID)
	var i McpSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.OrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMCPSessionByUser = `-- name: GetMCPSessionByUser :one
SELECT session_id, user_id, org_id, created_at, updated_at FROM mcp_sessions
WHERE user_id = ?1 AND org_id IS NOT NULL
ORDER BY updated_at DESC
LIMIT 1
`

// Fallback: get most recent org selection for a user (when session ID changes)
func (q *Queries) GetMCPSessionByUser(ctx context.Context, userID string) (McpSession, error) {
	row := q.db.QueryRowContext(ctx, getMCPSessionByUser, userID)
	var i McpSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.OrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMCPAPIKeysByUser = `-- name: ListMCPAPIKeysByUser :many
SELECT id, user_id, name, key_hash, key_prefix, scopes, last_used_at, expires_at, revoked_at, created_at, updated_at FROM mcp_api_keys
WHERE user_id = ?1
ORDER BY created_at DESC
`

func (q *Queries) ListMCPAPIKeysByUser(ctx context.Context, userID string) ([]McpApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listMCPAPIKeysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McpApiKey
	for rows.Next() {
		var i McpApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.KeyHash,
			&i.KeyPrefix,
			&i.Scopes,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMCPOAuthClients = `-- name: ListMCPOAuthClients :many
SELECT id, client_id, client_secret_hash, name, description, redirect_uris, scopes, is_confidential, is_active, created_at, updated_at FROM mcp_oauth_clients
WHERE is_active = 1
ORDER BY created_at DESC
`

func (q *Queries) ListMCPOAuthClients(ctx context.Context) ([]McpOauthClient, error) {
	rows, err := q.db.QueryContext(ctx, listMCPOAuthClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McpOauthClient
	for rows.Next() {
		var i McpOauthClient
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientSecretHash,
			&i.Name,
			&i.Description,
			&i.RedirectUris,
			&i.Scopes,
			&i.IsConfidential,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMCPOAuthCodeUsed = `-- name: MarkMCPOAuthCodeUsed :exec
UPDATE mcp_oauth_codes
SET used_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) MarkMCPOAuthCodeUsed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markMCPOAuthCodeUsed, id)
	return err
}

const revokeMCPAPIKey = `-- name: RevokeMCPAPIKey :exec
UPDATE mcp_api_keys
SET revoked_at = datetime('now'), updated_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) RevokeMCPAPIKey(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, revokeMCPAPIKey, id)
	return err
}

const revokeMCPOAuthToken = `-- name: RevokeMCPOAuthToken :exec
UPDATE mcp_oauth_tokens
SET revoked_at = datetime('now'), updated_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) RevokeMCPOAuthToken(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, revokeMCPOAuthToken, id)
	return err
}

const revokeMCPOAuthTokensByUser = `-- name: RevokeMCPOAuthTokensByUser :exec
UPDATE mcp_oauth_tokens
SET revoked_at = datetime('now'), updated_at = datetime('now')
WHERE user_id = ?1 AND revoked_at IS NULL
`

func (q *Queries) RevokeMCPOAuthTokensByUser(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, revokeMCPOAuthTokensByUser, userID)
	return err
}

const updateMCPAPIKeyLastUsed = `-- name: UpdateMCPAPIKeyLastUsed :exec
UPDATE mcp_api_keys
SET last_used_at = datetime('now'), updated_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) UpdateMCPAPIKeyLastUsed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateMCPAPIKeyLastUsed, id)
	return err
}

const updateMCPOAuthClient = `-- name: UpdateMCPOAuthClient :one
UPDATE mcp_oauth_clients
SET
    name = COALESCE(NULLIF(?1, ''), name),
    description = COALESCE(NULLIF(?2, ''), description),
    redirect_uris = COALESCE(NULLIF(?3, ''), redirect_uris),
    scopes = COALESCE(NULLIF(?4, ''), scopes),
    updated_at = datetime('now')
WHERE id = ?5
RETURNING id, client_id, client_secret_hash, name, description, redirect_uris, scopes, is_confidential, is_active, created_at, updated_at
`

type UpdateMCPOAuthClientParams struct {
	Name         interface{} `json:"name"`
	Description  interface{} `json:"description"`
	RedirectUris interface{} `json:"redirect_uris"`
	Scopes       interface{} `json:"scopes"`
	ID           string      `json:"id"`
}

func (q *Queries) UpdateMCPOAuthClient(ctx context.Context, arg UpdateMCPOAuthClientParams) (McpOauthClient, error) {
	row := q.db.QueryRowContext(ctx, updateMCPOAuthClient,
		arg.Name,
		arg.Description,
		arg.RedirectUris,
		arg.Scopes,
		arg.ID,
	)
	var i McpOauthClient
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecretHash,
		&i.Name,
		&i.Description,
		&i.RedirectUris,
		&i.Scopes,
		&i.IsConfidential,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMCPSession = `-- name: UpsertMCPSession :exec

INSERT INTO mcp_sessions (session_id, user_id, org_id, updated_at)
VALUES (?1, ?2, ?3, datetime('now'))
ON CONFLICT (session_id) DO UPDATE SET
    org_id = EXCLUDED.org_id,
    updated_at = datetime('now')
`

type UpsertMCPSessionParams struct {
	SessionID string         `json:"session_id"`
	UserID    string         `json:"user_id"`
	OrgID     sql.NullString `json:"org_id"`
}

// MCP Sessions (for persisting org selection across server restarts)
func (q *Queries) UpsertMCPSession(ctx context.Context, arg UpsertMCPSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertMCPSession, arg.SessionID, arg.UserID, arg.OrgID)
	return err
}
