// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package db

import (
	"context"
	"database/sql"
)

const addUserToOrganization = `-- name: AddUserToOrganization :exec
INSERT INTO org_users (org_id, user_id, role, created_at)
VALUES (?1, ?2, ?3, datetime('now'))
ON CONFLICT (org_id, user_id) DO UPDATE SET role = sqlc.arg(role)
`

type AddUserToOrganizationParams struct {
	OrgID  string         `json:"org_id"`
	UserID string         `json:"user_id"`
	Role   sql.NullString `json:"role"`
}

func (q *Queries) AddUserToOrganization(ctx context.Context, arg AddUserToOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, addUserToOrganization, arg.OrgID, arg.UserID, arg.Role)
	return err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (
    id, name, slug, api_key, max_contacts, settings, app_url, created_at, updated_at
) VALUES (
    ?1, ?2, ?3, ?4,
    ?5, ?6, ?7,
    datetime('now'), datetime('now')
)
RETURNING id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at
`

type CreateOrganizationParams struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Slug        string         `json:"slug"`
	ApiKey      string         `json:"api_key"`
	MaxContacts sql.NullInt64  `json:"max_contacts"`
	Settings    sql.NullString `json:"settings"`
	AppUrl      sql.NullString `json:"app_url"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ApiKey,
		arg.MaxContacts,
		arg.Settings,
		arg.AppUrl,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = ?1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, id)
	return err
}

const getOrgEmailSettings = `-- name: GetOrgEmailSettings :one
SELECT from_name, from_email, reply_to
FROM organizations
WHERE id = ?1
`

type GetOrgEmailSettingsRow struct {
	FromName  sql.NullString `json:"from_name"`
	FromEmail sql.NullString `json:"from_email"`
	ReplyTo   sql.NullString `json:"reply_to"`
}

func (q *Queries) GetOrgEmailSettings(ctx context.Context, id string) (GetOrgEmailSettingsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrgEmailSettings, id)
	var i GetOrgEmailSettingsRow
	err := row.Scan(&i.FromName, &i.FromEmail, &i.ReplyTo)
	return i, err
}

const getOrganizationByAPIKey = `-- name: GetOrganizationByAPIKey :one
SELECT id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at FROM organizations
WHERE api_key = ?1
LIMIT 1
`

func (q *Queries) GetOrganizationByAPIKey(ctx context.Context, apiKey string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByAPIKey, apiKey)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at FROM organizations
WHERE id = ?1
LIMIT 1
`

func (q *Queries) GetOrganizationByID(ctx context.Context, id string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationBySlug = `-- name: GetOrganizationBySlug :one
SELECT id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at FROM organizations
WHERE slug = ?1
LIMIT 1
`

func (q *Queries) GetOrganizationBySlug(ctx context.Context, slug string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationBySlug, slug)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationUsers = `-- name: GetOrganizationUsers :many
SELECT u.id, u.email, u.password_hash, u.name, u.role, u.status, u.email_verified, u.phone, u.avatar_url, u.last_login_at, u.password_changed_at, u.failed_login_attempts, u.locked_until, u.created_at, u.updated_at, ou.role as org_role, ou.created_at as joined_at
FROM users u
JOIN org_users ou ON u.id = ou.user_id
WHERE ou.org_id = ?1
ORDER BY ou.created_at
`

type GetOrganizationUsersRow struct {
	ID                  string         `json:"id"`
	Email               string         `json:"email"`
	PasswordHash        string         `json:"password_hash"`
	Name                string         `json:"name"`
	Role                string         `json:"role"`
	Status              string         `json:"status"`
	EmailVerified       int64          `json:"email_verified"`
	Phone               sql.NullString `json:"phone"`
	AvatarUrl           sql.NullString `json:"avatar_url"`
	LastLoginAt         sql.NullString `json:"last_login_at"`
	PasswordChangedAt   sql.NullString `json:"password_changed_at"`
	FailedLoginAttempts sql.NullInt64  `json:"failed_login_attempts"`
	LockedUntil         sql.NullString `json:"locked_until"`
	CreatedAt           sql.NullString `json:"created_at"`
	UpdatedAt           sql.NullString `json:"updated_at"`
	OrgRole             sql.NullString `json:"org_role"`
	JoinedAt            sql.NullString `json:"joined_at"`
}

func (q *Queries) GetOrganizationUsers(ctx context.Context, orgID string) ([]GetOrganizationUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationUsers, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationUsersRow
	for rows.Next() {
		var i GetOrganizationUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Name,
			&i.Role,
			&i.Status,
			&i.EmailVerified,
			&i.Phone,
			&i.AvatarUrl,
			&i.LastLoginAt,
			&i.PasswordChangedAt,
			&i.FailedLoginAttempts,
			&i.LockedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgRole,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrganizations = `-- name: GetUserOrganizations :many
SELECT o.id, o.name, o.slug, o.api_key, o.api_key_created_at, o.from_name, o.from_email, o.reply_to, o.max_contacts, o.settings, o.app_url, o.created_at, o.updated_at, ou.role as user_role
FROM organizations o
JOIN org_users ou ON o.id = ou.org_id
WHERE ou.user_id = ?1
ORDER BY o.created_at
`

type GetUserOrganizationsRow struct {
	ID              string         `json:"id"`
	Name            string         `json:"name"`
	Slug            string         `json:"slug"`
	ApiKey          string         `json:"api_key"`
	ApiKeyCreatedAt sql.NullString `json:"api_key_created_at"`
	FromName        sql.NullString `json:"from_name"`
	FromEmail       sql.NullString `json:"from_email"`
	ReplyTo         sql.NullString `json:"reply_to"`
	MaxContacts     sql.NullInt64  `json:"max_contacts"`
	Settings        sql.NullString `json:"settings"`
	AppUrl          sql.NullString `json:"app_url"`
	CreatedAt       sql.NullString `json:"created_at"`
	UpdatedAt       sql.NullString `json:"updated_at"`
	UserRole        sql.NullString `json:"user_role"`
}

func (q *Queries) GetUserOrganizations(ctx context.Context, userID string) ([]GetUserOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrganizationsRow
	for rows.Next() {
		var i GetUserOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ApiKey,
			&i.ApiKeyCreatedAt,
			&i.FromName,
			&i.FromEmail,
			&i.ReplyTo,
			&i.MaxContacts,
			&i.Settings,
			&i.AppUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at FROM organizations
ORDER BY created_at DESC
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ApiKey,
			&i.ApiKeyCreatedAt,
			&i.FromName,
			&i.FromEmail,
			&i.ReplyTo,
			&i.MaxContacts,
			&i.Settings,
			&i.AppUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const regenerateAPIKey = `-- name: RegenerateAPIKey :one
UPDATE organizations
SET
    api_key = ?1,
    api_key_created_at = datetime('now'),
    updated_at = datetime('now')
WHERE id = ?2
RETURNING id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at
`

type RegenerateAPIKeyParams struct {
	ApiKey string `json:"api_key"`
	ID     string `json:"id"`
}

func (q *Queries) RegenerateAPIKey(ctx context.Context, arg RegenerateAPIKeyParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, regenerateAPIKey, arg.ApiKey, arg.ID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeUserFromOrganization = `-- name: RemoveUserFromOrganization :exec
DELETE FROM org_users
WHERE org_id = ?1 AND user_id = ?2
`

type RemoveUserFromOrganizationParams struct {
	OrgID  string `json:"org_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) RemoveUserFromOrganization(ctx context.Context, arg RemoveUserFromOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromOrganization, arg.OrgID, arg.UserID)
	return err
}

const updateOrgEmailSettings = `-- name: UpdateOrgEmailSettings :one
UPDATE organizations
SET
    from_name = COALESCE(NULLIF(?1, ''), from_name),
    from_email = COALESCE(NULLIF(?2, ''), from_email),
    reply_to = COALESCE(NULLIF(?3, ''), reply_to),
    updated_at = datetime('now')
WHERE id = ?4
RETURNING id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at
`

type UpdateOrgEmailSettingsParams struct {
	FromName  interface{} `json:"from_name"`
	FromEmail interface{} `json:"from_email"`
	ReplyTo   interface{} `json:"reply_to"`
	ID        string      `json:"id"`
}

func (q *Queries) UpdateOrgEmailSettings(ctx context.Context, arg UpdateOrgEmailSettingsParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, updateOrgEmailSettings,
		arg.FromName,
		arg.FromEmail,
		arg.ReplyTo,
		arg.ID,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organizations
SET
    name = COALESCE(NULLIF(?1, ''), name),
    max_contacts = COALESCE(?2, max_contacts),
    settings = COALESCE(?3, settings),
    app_url = COALESCE(NULLIF(?4, ''), app_url),
    updated_at = datetime('now')
WHERE id = ?5
RETURNING id, name, slug, api_key, api_key_created_at, from_name, from_email, reply_to, max_contacts, settings, app_url, created_at, updated_at
`

type UpdateOrganizationParams struct {
	Name        interface{}    `json:"name"`
	MaxContacts sql.NullInt64  `json:"max_contacts"`
	Settings    sql.NullString `json:"settings"`
	AppUrl      interface{}    `json:"app_url"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, updateOrganization,
		arg.Name,
		arg.MaxContacts,
		arg.Settings,
		arg.AppUrl,
		arg.ID,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.FromName,
		&i.FromEmail,
		&i.ReplyTo,
		&i.MaxContacts,
		&i.Settings,
		&i.AppUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
