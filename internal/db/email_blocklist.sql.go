// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_blocklist.sql

package db

import (
	"context"
	"database/sql"
)

const addBlockedDomain = `-- name: AddBlockedDomain :one
INSERT INTO blocked_domains (id, org_id, domain)
VALUES (?1, ?2, LOWER(?3))
ON CONFLICT (org_id, domain) DO NOTHING
RETURNING id, org_id, domain, reason, block_attempts, created_at, updated_at
`

type AddBlockedDomainParams struct {
	ID     int64  `json:"id"`
	OrgID  string `json:"org_id"`
	Domain string `json:"domain"`
}

func (q *Queries) AddBlockedDomain(ctx context.Context, arg AddBlockedDomainParams) (BlockedDomain, error) {
	row := q.db.QueryRowContext(ctx, addBlockedDomain, arg.ID, arg.OrgID, arg.Domain)
	var i BlockedDomain
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Domain,
		&i.Reason,
		&i.BlockAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addToSuppressionList = `-- name: AddToSuppressionList :one

INSERT INTO suppression_list (org_id, email, email_lower, reason, source)
VALUES (?1, ?2, LOWER(?2), ?3, ?4)
ON CONFLICT (org_id, email_lower) DO UPDATE SET
    reason = COALESCE(EXCLUDED.reason, suppression_list.reason),
    source = EXCLUDED.source
RETURNING id, org_id, email, email_lower, reason, source, block_attempts, created_at
`

type AddToSuppressionListParams struct {
	OrgID  string         `json:"org_id"`
	Email  string         `json:"email"`
	Reason sql.NullString `json:"reason"`
	Source sql.NullString `json:"source"`
}

// ========== SUPPRESSION LIST ==========
func (q *Queries) AddToSuppressionList(ctx context.Context, arg AddToSuppressionListParams) (SuppressionList, error) {
	row := q.db.QueryRowContext(ctx, addToSuppressionList,
		arg.OrgID,
		arg.Email,
		arg.Reason,
		arg.Source,
	)
	var i SuppressionList
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.EmailLower,
		&i.Reason,
		&i.Source,
		&i.BlockAttempts,
		&i.CreatedAt,
	)
	return i, err
}

const blockContactByEmail = `-- name: BlockContactByEmail :exec

UPDATE contacts SET blocked_at = datetime('now'), updated_at = datetime('now')
WHERE LOWER(email) = LOWER(?1) AND blocked_at IS NULL
`

// ========== BLOCK CONTACT BY EMAIL ==========
func (q *Queries) BlockContactByEmail(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, blockContactByEmail, email)
	return err
}

const bulkInsertBlockedDomains = `-- name: BulkInsertBlockedDomains :exec
INSERT INTO blocked_domains (org_id, domain, reason)
VALUES (?1, LOWER(?2), ?3)
ON CONFLICT (org_id, domain) DO NOTHING
`

type BulkInsertBlockedDomainsParams struct {
	OrgID  string         `json:"org_id"`
	Domain string         `json:"domain"`
	Reason sql.NullString `json:"reason"`
}

func (q *Queries) BulkInsertBlockedDomains(ctx context.Context, arg BulkInsertBlockedDomainsParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertBlockedDomains, arg.OrgID, arg.Domain, arg.Reason)
	return err
}

const cancelImportJob = `-- name: CancelImportJob :exec
UPDATE import_jobs
SET status = 'cancelled', completed_at = datetime('now')
WHERE id = ?1 AND org_id = ?2 AND status IN ('pending', 'processing')
`

type CancelImportJobParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) CancelImportJob(ctx context.Context, arg CancelImportJobParams) error {
	_, err := q.db.ExecContext(ctx, cancelImportJob, arg.ID, arg.OrgID)
	return err
}

const clearSuppressionList = `-- name: ClearSuppressionList :exec
DELETE FROM suppression_list WHERE org_id = ?1
`

func (q *Queries) ClearSuppressionList(ctx context.Context, orgID string) error {
	_, err := q.db.ExecContext(ctx, clearSuppressionList, orgID)
	return err
}

const countBlockedDomains = `-- name: CountBlockedDomains :one
SELECT COUNT(*) FROM blocked_domains WHERE org_id = ?1
`

func (q *Queries) CountBlockedDomains(ctx context.Context, orgID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBlockedDomains, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBouncesInDateRange = `-- name: CountBouncesInDateRange :one
SELECT COUNT(*) FROM email_bounce
WHERE created_at >= ?1 AND created_at <= ?2
`

type CountBouncesInDateRangeParams struct {
	StartDate sql.NullString `json:"start_date"`
	EndDate   sql.NullString `json:"end_date"`
}

func (q *Queries) CountBouncesInDateRange(ctx context.Context, arg CountBouncesInDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBouncesInDateRange, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countComplaintsInDateRange = `-- name: CountComplaintsInDateRange :one
SELECT COUNT(*) FROM email_complaint
WHERE created_at >= ?1 AND created_at <= ?2
`

type CountComplaintsInDateRangeParams struct {
	StartDate sql.NullString `json:"start_date"`
	EndDate   sql.NullString `json:"end_date"`
}

func (q *Queries) CountComplaintsInDateRange(ctx context.Context, arg CountComplaintsInDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countComplaintsInDateRange, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuppressedEmails = `-- name: CountSuppressedEmails :one
SELECT COUNT(*) FROM suppression_list WHERE org_id = ?1
`

func (q *Queries) CountSuppressedEmails(ctx context.Context, orgID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSuppressedEmails, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlockedDomain = `-- name: CreateBlockedDomain :one

INSERT INTO blocked_domains (org_id, domain, reason)
VALUES (?1, LOWER(?2), ?3)
ON CONFLICT (org_id, domain) DO UPDATE SET
    reason = COALESCE(EXCLUDED.reason, blocked_domains.reason),
    updated_at = datetime('now')
RETURNING id, org_id, domain, reason, block_attempts, created_at, updated_at
`

type CreateBlockedDomainParams struct {
	OrgID  string         `json:"org_id"`
	Domain string         `json:"domain"`
	Reason sql.NullString `json:"reason"`
}

// ========== BLOCKED DOMAINS ==========
func (q *Queries) CreateBlockedDomain(ctx context.Context, arg CreateBlockedDomainParams) (BlockedDomain, error) {
	row := q.db.QueryRowContext(ctx, createBlockedDomain, arg.OrgID, arg.Domain, arg.Reason)
	var i BlockedDomain
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Domain,
		&i.Reason,
		&i.BlockAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmailBounce = `-- name: CreateEmailBounce :one


INSERT INTO email_bounce (
    email, email_lower, bounce_type, bounce_subtype,
    diagnostic_code, source_email, message_id, raw_notification, created_at
) VALUES (?1, LOWER(?2), ?3, ?4, ?5, ?6, ?7, ?8, datetime('now'))
ON CONFLICT (email_lower) DO UPDATE
SET bounce_type = EXCLUDED.bounce_type,
    bounce_subtype = EXCLUDED.bounce_subtype,
    diagnostic_code = EXCLUDED.diagnostic_code,
    source_email = EXCLUDED.source_email,
    message_id = EXCLUDED.message_id,
    raw_notification = EXCLUDED.raw_notification,
    created_at = datetime('now')
RETURNING id, email, email_lower, bounce_type, bounce_subtype, diagnostic_code, source_email, message_id, raw_notification, created_at
`

type CreateEmailBounceParams struct {
	Email           string         `json:"email"`
	EmailForLower   string         `json:"email_for_lower"`
	BounceType      string         `json:"bounce_type"`
	BounceSubtype   sql.NullString `json:"bounce_subtype"`
	DiagnosticCode  sql.NullString `json:"diagnostic_code"`
	SourceEmail     sql.NullString `json:"source_email"`
	MessageID       sql.NullString `json:"message_id"`
	RawNotification sql.NullString `json:"raw_notification"`
}

// Email blocklist queries for bounce and complaint management
// ========== BOUNCES ==========
func (q *Queries) CreateEmailBounce(ctx context.Context, arg CreateEmailBounceParams) (EmailBounce, error) {
	row := q.db.QueryRowContext(ctx, createEmailBounce,
		arg.Email,
		arg.EmailForLower,
		arg.BounceType,
		arg.BounceSubtype,
		arg.DiagnosticCode,
		arg.SourceEmail,
		arg.MessageID,
		arg.RawNotification,
	)
	var i EmailBounce
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailLower,
		&i.BounceType,
		&i.BounceSubtype,
		&i.DiagnosticCode,
		&i.SourceEmail,
		&i.MessageID,
		&i.RawNotification,
		&i.CreatedAt,
	)
	return i, err
}

const createEmailComplaint = `-- name: CreateEmailComplaint :one

INSERT INTO email_complaint (
    email, email_lower, complaint_type, feedback_id,
    source_email, message_id, raw_notification, created_at
) VALUES (?1, LOWER(?2), ?3, ?4, ?5, ?6, ?7, datetime('now'))
ON CONFLICT (email_lower) DO UPDATE
SET complaint_type = EXCLUDED.complaint_type,
    feedback_id = EXCLUDED.feedback_id,
    source_email = EXCLUDED.source_email,
    message_id = EXCLUDED.message_id,
    raw_notification = EXCLUDED.raw_notification,
    created_at = datetime('now')
RETURNING id, email, email_lower, complaint_type, feedback_id, source_email, message_id, raw_notification, created_at
`

type CreateEmailComplaintParams struct {
	Email           string         `json:"email"`
	EmailForLower   string         `json:"email_for_lower"`
	ComplaintType   sql.NullString `json:"complaint_type"`
	FeedbackID      sql.NullString `json:"feedback_id"`
	SourceEmail     sql.NullString `json:"source_email"`
	MessageID       sql.NullString `json:"message_id"`
	RawNotification sql.NullString `json:"raw_notification"`
}

// ========== COMPLAINTS ==========
func (q *Queries) CreateEmailComplaint(ctx context.Context, arg CreateEmailComplaintParams) (EmailComplaint, error) {
	row := q.db.QueryRowContext(ctx, createEmailComplaint,
		arg.Email,
		arg.EmailForLower,
		arg.ComplaintType,
		arg.FeedbackID,
		arg.SourceEmail,
		arg.MessageID,
		arg.RawNotification,
	)
	var i EmailComplaint
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailLower,
		&i.ComplaintType,
		&i.FeedbackID,
		&i.SourceEmail,
		&i.MessageID,
		&i.RawNotification,
		&i.CreatedAt,
	)
	return i, err
}

const createImportJob = `-- name: CreateImportJob :one

INSERT INTO import_jobs (id, org_id, list_id, type, filename, options)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING id, org_id, list_id, type, status, filename, total_rows, processed_rows, success_count, error_count, skip_count, errors, options, started_at, completed_at, created_at
`

type CreateImportJobParams struct {
	ID       string         `json:"id"`
	OrgID    string         `json:"org_id"`
	ListID   sql.NullInt64  `json:"list_id"`
	Type     string         `json:"type"`
	Filename string         `json:"filename"`
	Options  sql.NullString `json:"options"`
}

// ========== IMPORT JOBS ==========
func (q *Queries) CreateImportJob(ctx context.Context, arg CreateImportJobParams) (ImportJob, error) {
	row := q.db.QueryRowContext(ctx, createImportJob,
		arg.ID,
		arg.OrgID,
		arg.ListID,
		arg.Type,
		arg.Filename,
		arg.Options,
	)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Type,
		&i.Status,
		&i.Filename,
		&i.TotalRows,
		&i.ProcessedRows,
		&i.SuccessCount,
		&i.ErrorCount,
		&i.SkipCount,
		&i.Errors,
		&i.Options,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBlockedDomain = `-- name: DeleteBlockedDomain :exec
DELETE FROM blocked_domains
WHERE org_id = ?1 AND domain = LOWER(?2)
`

type DeleteBlockedDomainParams struct {
	OrgID  string `json:"org_id"`
	Domain string `json:"domain"`
}

func (q *Queries) DeleteBlockedDomain(ctx context.Context, arg DeleteBlockedDomainParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlockedDomain, arg.OrgID, arg.Domain)
	return err
}

const deleteBlockedDomainByID = `-- name: DeleteBlockedDomainByID :exec
DELETE FROM blocked_domains WHERE id = ?1 AND org_id = ?2
`

type DeleteBlockedDomainByIDParams struct {
	ID    int64  `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) DeleteBlockedDomainByID(ctx context.Context, arg DeleteBlockedDomainByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlockedDomainByID, arg.ID, arg.OrgID)
	return err
}

const deleteEmailBounce = `-- name: DeleteEmailBounce :exec
DELETE FROM email_bounce WHERE email_lower = LOWER(?1)
`

func (q *Queries) DeleteEmailBounce(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailBounce, email)
	return err
}

const deleteEmailComplaint = `-- name: DeleteEmailComplaint :exec
DELETE FROM email_complaint WHERE email_lower = LOWER(?1)
`

func (q *Queries) DeleteEmailComplaint(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailComplaint, email)
	return err
}

const deleteFromSuppressionList = `-- name: DeleteFromSuppressionList :exec
DELETE FROM suppression_list
WHERE org_id = ?1 AND email_lower = LOWER(?2)
`

type DeleteFromSuppressionListParams struct {
	OrgID string `json:"org_id"`
	Email string `json:"email"`
}

func (q *Queries) DeleteFromSuppressionList(ctx context.Context, arg DeleteFromSuppressionListParams) error {
	_, err := q.db.ExecContext(ctx, deleteFromSuppressionList, arg.OrgID, arg.Email)
	return err
}

const deleteImportJob = `-- name: DeleteImportJob :exec
DELETE FROM import_jobs WHERE id = ?1 AND org_id = ?2
`

type DeleteImportJobParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) DeleteImportJob(ctx context.Context, arg DeleteImportJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteImportJob, arg.ID, arg.OrgID)
	return err
}

const deleteSuppressionByID = `-- name: DeleteSuppressionByID :exec
DELETE FROM suppression_list WHERE id = ?1 AND org_id = ?2
`

type DeleteSuppressionByIDParams struct {
	ID    int64  `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) DeleteSuppressionByID(ctx context.Context, arg DeleteSuppressionByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteSuppressionByID, arg.ID, arg.OrgID)
	return err
}

const getBlockedDomain = `-- name: GetBlockedDomain :one
SELECT id, org_id, domain, reason, block_attempts, created_at, updated_at FROM blocked_domains
WHERE org_id = ?1 AND domain = LOWER(?2)
`

type GetBlockedDomainParams struct {
	OrgID  string `json:"org_id"`
	Domain string `json:"domain"`
}

func (q *Queries) GetBlockedDomain(ctx context.Context, arg GetBlockedDomainParams) (BlockedDomain, error) {
	row := q.db.QueryRowContext(ctx, getBlockedDomain, arg.OrgID, arg.Domain)
	var i BlockedDomain
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Domain,
		&i.Reason,
		&i.BlockAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmailBounce = `-- name: GetEmailBounce :one
SELECT id, email, email_lower, bounce_type, bounce_subtype, diagnostic_code, source_email, message_id, raw_notification, created_at FROM email_bounce
WHERE email_lower = LOWER(?1)
`

func (q *Queries) GetEmailBounce(ctx context.Context, email string) (EmailBounce, error) {
	row := q.db.QueryRowContext(ctx, getEmailBounce, email)
	var i EmailBounce
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailLower,
		&i.BounceType,
		&i.BounceSubtype,
		&i.DiagnosticCode,
		&i.SourceEmail,
		&i.MessageID,
		&i.RawNotification,
		&i.CreatedAt,
	)
	return i, err
}

const getEmailComplaint = `-- name: GetEmailComplaint :one
SELECT id, email, email_lower, complaint_type, feedback_id, source_email, message_id, raw_notification, created_at FROM email_complaint
WHERE email_lower = LOWER(?1)
`

func (q *Queries) GetEmailComplaint(ctx context.Context, email string) (EmailComplaint, error) {
	row := q.db.QueryRowContext(ctx, getEmailComplaint, email)
	var i EmailComplaint
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailLower,
		&i.ComplaintType,
		&i.FeedbackID,
		&i.SourceEmail,
		&i.MessageID,
		&i.RawNotification,
		&i.CreatedAt,
	)
	return i, err
}

const getImportJob = `-- name: GetImportJob :one
SELECT id, org_id, list_id, type, status, filename, total_rows, processed_rows, success_count, error_count, skip_count, errors, options, started_at, completed_at, created_at FROM import_jobs WHERE id = ?1 AND org_id = ?2
`

type GetImportJobParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) GetImportJob(ctx context.Context, arg GetImportJobParams) (ImportJob, error) {
	row := q.db.QueryRowContext(ctx, getImportJob, arg.ID, arg.OrgID)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Type,
		&i.Status,
		&i.Filename,
		&i.TotalRows,
		&i.ProcessedRows,
		&i.SuccessCount,
		&i.ErrorCount,
		&i.SkipCount,
		&i.Errors,
		&i.Options,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSuppressedEmail = `-- name: GetSuppressedEmail :one
SELECT id, org_id, email, email_lower, reason, source, block_attempts, created_at FROM suppression_list
WHERE org_id = ?1 AND email_lower = LOWER(?2)
`

type GetSuppressedEmailParams struct {
	OrgID string `json:"org_id"`
	Email string `json:"email"`
}

func (q *Queries) GetSuppressedEmail(ctx context.Context, arg GetSuppressedEmailParams) (SuppressionList, error) {
	row := q.db.QueryRowContext(ctx, getSuppressedEmail, arg.OrgID, arg.Email)
	var i SuppressionList
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.EmailLower,
		&i.Reason,
		&i.Source,
		&i.BlockAttempts,
		&i.CreatedAt,
	)
	return i, err
}

const incrementBlockedDomainAttempts = `-- name: IncrementBlockedDomainAttempts :exec
UPDATE blocked_domains
SET block_attempts = block_attempts + 1, updated_at = datetime('now')
WHERE org_id = ?1 AND domain = LOWER(?2)
`

type IncrementBlockedDomainAttemptsParams struct {
	OrgID  string `json:"org_id"`
	Domain string `json:"domain"`
}

func (q *Queries) IncrementBlockedDomainAttempts(ctx context.Context, arg IncrementBlockedDomainAttemptsParams) error {
	_, err := q.db.ExecContext(ctx, incrementBlockedDomainAttempts, arg.OrgID, arg.Domain)
	return err
}

const incrementSuppressionAttempts = `-- name: IncrementSuppressionAttempts :exec
UPDATE suppression_list
SET block_attempts = block_attempts + 1
WHERE org_id = ?1 AND email_lower = LOWER(?2)
`

type IncrementSuppressionAttemptsParams struct {
	OrgID string `json:"org_id"`
	Email string `json:"email"`
}

func (q *Queries) IncrementSuppressionAttempts(ctx context.Context, arg IncrementSuppressionAttemptsParams) error {
	_, err := q.db.ExecContext(ctx, incrementSuppressionAttempts, arg.OrgID, arg.Email)
	return err
}

const isDomainBlocked = `-- name: IsDomainBlocked :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM blocked_domains
WHERE org_id = ?1 AND domain = LOWER(?2)
`

type IsDomainBlockedParams struct {
	OrgID  string `json:"org_id"`
	Domain string `json:"domain"`
}

func (q *Queries) IsDomainBlocked(ctx context.Context, arg IsDomainBlockedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isDomainBlocked, arg.OrgID, arg.Domain)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const isEmailBlocked = `-- name: IsEmailBlocked :one

SELECT CASE WHEN (
    (SELECT COUNT(*) FROM email_bounce WHERE email_lower = LOWER(?1)) +
    (SELECT COUNT(*) FROM email_complaint WHERE email_lower = LOWER(?2))
) > 0 THEN 1 ELSE 0 END as found
`

type IsEmailBlockedParams struct {
	Email  string `json:"email"`
	Email2 string `json:"email_2"`
}

// ========== COMBINED CHECK ==========
func (q *Queries) IsEmailBlocked(ctx context.Context, arg IsEmailBlockedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmailBlocked, arg.Email, arg.Email2)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const isEmailBounced = `-- name: IsEmailBounced :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM email_bounce WHERE email_lower = LOWER(?1)
`

func (q *Queries) IsEmailBounced(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmailBounced, email)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const isEmailComplaint = `-- name: IsEmailComplaint :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM email_complaint WHERE email_lower = LOWER(?1)
`

func (q *Queries) IsEmailComplaint(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmailComplaint, email)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const isEmailFullyBlocked = `-- name: IsEmailFullyBlocked :one

SELECT CASE WHEN (
    (SELECT COUNT(*) FROM email_bounce WHERE email_lower = LOWER(?1)) +
    (SELECT COUNT(*) FROM email_complaint WHERE email_lower = LOWER(?1)) +
    (SELECT COUNT(*) FROM suppression_list sl WHERE sl.org_id = ?2 AND sl.email_lower = LOWER(?1)) +
    (SELECT COUNT(*) FROM blocked_domains bd WHERE bd.org_id = ?2 AND bd.domain = LOWER(SUBSTR(?1, INSTR(?1, '@') + 1)))
) > 0 THEN 1 ELSE 0 END as found
`

type IsEmailFullyBlockedParams struct {
	CheckEmail string `json:"check_email"`
	CheckOrgID string `json:"check_org_id"`
}

// ========== COMBINED BLOCK CHECK (Enhanced) ==========
func (q *Queries) IsEmailFullyBlocked(ctx context.Context, arg IsEmailFullyBlockedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmailFullyBlocked, arg.CheckEmail, arg.CheckOrgID)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const isEmailSuppressed = `-- name: IsEmailSuppressed :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM suppression_list
WHERE org_id = ?1 AND email_lower = LOWER(?2)
`

type IsEmailSuppressedParams struct {
	OrgID string `json:"org_id"`
	Email string `json:"email"`
}

func (q *Queries) IsEmailSuppressed(ctx context.Context, arg IsEmailSuppressedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmailSuppressed, arg.OrgID, arg.Email)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const listBlockedDomains = `-- name: ListBlockedDomains :many
SELECT id, org_id, domain, reason, block_attempts, created_at, updated_at FROM blocked_domains
WHERE org_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListBlockedDomainsParams struct {
	OrgID      string `json:"org_id"`
	PageOffset int64  `json:"page_offset"`
	PageSize   int64  `json:"page_size"`
}

func (q *Queries) ListBlockedDomains(ctx context.Context, arg ListBlockedDomainsParams) ([]BlockedDomain, error) {
	rows, err := q.db.QueryContext(ctx, listBlockedDomains, arg.OrgID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BlockedDomain
	for rows.Next() {
		var i BlockedDomain
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Domain,
			&i.Reason,
			&i.BlockAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImportJobs = `-- name: ListImportJobs :many
SELECT id, org_id, list_id, type, status, filename, total_rows, processed_rows, success_count, error_count, skip_count, errors, options, started_at, completed_at, created_at FROM import_jobs
WHERE org_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListImportJobsParams struct {
	OrgID      string `json:"org_id"`
	PageOffset int64  `json:"page_offset"`
	PageSize   int64  `json:"page_size"`
}

func (q *Queries) ListImportJobs(ctx context.Context, arg ListImportJobsParams) ([]ImportJob, error) {
	rows, err := q.db.QueryContext(ctx, listImportJobs, arg.OrgID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImportJob
	for rows.Next() {
		var i ImportJob
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ListID,
			&i.Type,
			&i.Status,
			&i.Filename,
			&i.TotalRows,
			&i.ProcessedRows,
			&i.SuccessCount,
			&i.ErrorCount,
			&i.SkipCount,
			&i.Errors,
			&i.Options,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingImportJobs = `-- name: ListPendingImportJobs :many
SELECT id, org_id, list_id, type, status, filename, total_rows, processed_rows, success_count, error_count, skip_count, errors, options, started_at, completed_at, created_at FROM import_jobs
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT 10
`

func (q *Queries) ListPendingImportJobs(ctx context.Context) ([]ImportJob, error) {
	rows, err := q.db.QueryContext(ctx, listPendingImportJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImportJob
	for rows.Next() {
		var i ImportJob
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ListID,
			&i.Type,
			&i.Status,
			&i.Filename,
			&i.TotalRows,
			&i.ProcessedRows,
			&i.SuccessCount,
			&i.ErrorCount,
			&i.SkipCount,
			&i.Errors,
			&i.Options,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentBounces = `-- name: ListRecentBounces :many
SELECT id, email, email_lower, bounce_type, bounce_subtype, diagnostic_code, source_email, message_id, raw_notification, created_at FROM email_bounce
ORDER BY created_at DESC
LIMIT ?2 OFFSET ?1
`

type ListRecentBouncesParams struct {
	PageOffset int64 `json:"page_offset"`
	PageSize   int64 `json:"page_size"`
}

func (q *Queries) ListRecentBounces(ctx context.Context, arg ListRecentBouncesParams) ([]EmailBounce, error) {
	rows, err := q.db.QueryContext(ctx, listRecentBounces, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailBounce
	for rows.Next() {
		var i EmailBounce
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EmailLower,
			&i.BounceType,
			&i.BounceSubtype,
			&i.DiagnosticCode,
			&i.SourceEmail,
			&i.MessageID,
			&i.RawNotification,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentComplaints = `-- name: ListRecentComplaints :many
SELECT id, email, email_lower, complaint_type, feedback_id, source_email, message_id, raw_notification, created_at FROM email_complaint
ORDER BY created_at DESC
LIMIT ?2 OFFSET ?1
`

type ListRecentComplaintsParams struct {
	PageOffset int64 `json:"page_offset"`
	PageSize   int64 `json:"page_size"`
}

func (q *Queries) ListRecentComplaints(ctx context.Context, arg ListRecentComplaintsParams) ([]EmailComplaint, error) {
	rows, err := q.db.QueryContext(ctx, listRecentComplaints, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailComplaint
	for rows.Next() {
		var i EmailComplaint
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EmailLower,
			&i.ComplaintType,
			&i.FeedbackID,
			&i.SourceEmail,
			&i.MessageID,
			&i.RawNotification,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppressedEmails = `-- name: ListSuppressedEmails :many
SELECT id, org_id, email, email_lower, reason, source, block_attempts, created_at FROM suppression_list
WHERE org_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListSuppressedEmailsParams struct {
	OrgID      string `json:"org_id"`
	PageOffset int64  `json:"page_offset"`
	PageSize   int64  `json:"page_size"`
}

func (q *Queries) ListSuppressedEmails(ctx context.Context, arg ListSuppressedEmailsParams) ([]SuppressionList, error) {
	rows, err := q.db.QueryContext(ctx, listSuppressedEmails, arg.OrgID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SuppressionList
	for rows.Next() {
		var i SuppressionList
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Email,
			&i.EmailLower,
			&i.Reason,
			&i.Source,
			&i.BlockAttempts,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setImportJobErrors = `-- name: SetImportJobErrors :exec
UPDATE import_jobs
SET errors = ?1
WHERE id = ?2
`

type SetImportJobErrorsParams struct {
	Errors sql.NullString `json:"errors"`
	ID     string         `json:"id"`
}

func (q *Queries) SetImportJobErrors(ctx context.Context, arg SetImportJobErrorsParams) error {
	_, err := q.db.ExecContext(ctx, setImportJobErrors, arg.Errors, arg.ID)
	return err
}

const setImportJobTotalRows = `-- name: SetImportJobTotalRows :exec
UPDATE import_jobs
SET total_rows = ?1
WHERE id = ?2
`

type SetImportJobTotalRowsParams struct {
	TotalRows sql.NullInt64 `json:"total_rows"`
	ID        string        `json:"id"`
}

func (q *Queries) SetImportJobTotalRows(ctx context.Context, arg SetImportJobTotalRowsParams) error {
	_, err := q.db.ExecContext(ctx, setImportJobTotalRows, arg.TotalRows, arg.ID)
	return err
}

const updateImportJobProgress = `-- name: UpdateImportJobProgress :exec
UPDATE import_jobs
SET processed_rows = ?1,
    success_count = ?2,
    error_count = ?3,
    skip_count = ?4
WHERE id = ?5
`

type UpdateImportJobProgressParams struct {
	ProcessedRows sql.NullInt64 `json:"processed_rows"`
	SuccessCount  sql.NullInt64 `json:"success_count"`
	ErrorCount    sql.NullInt64 `json:"error_count"`
	SkipCount     sql.NullInt64 `json:"skip_count"`
	ID            string        `json:"id"`
}

func (q *Queries) UpdateImportJobProgress(ctx context.Context, arg UpdateImportJobProgressParams) error {
	_, err := q.db.ExecContext(ctx, updateImportJobProgress,
		arg.ProcessedRows,
		arg.SuccessCount,
		arg.ErrorCount,
		arg.SkipCount,
		arg.ID,
	)
	return err
}

const updateImportJobStatus = `-- name: UpdateImportJobStatus :exec
UPDATE import_jobs
SET status = ?1,
    started_at = CASE WHEN ?1 = 'processing' THEN datetime('now') ELSE started_at END,
    completed_at = CASE WHEN sqlc.arg(status) IN ('completed', 'failed', 'cancelled') THEN datetime('now') ELSE completed_at END
WHERE id = ?2
`

type UpdateImportJobStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     string         `json:"id"`
}

func (q *Queries) UpdateImportJobStatus(ctx context.Context, arg UpdateImportJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateImportJobStatus, arg.Status, arg.ID)
	return err
}
