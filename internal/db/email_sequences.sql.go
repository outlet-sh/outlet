// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_sequences.sql

package db

import (
	"context"
	"database/sql"
)

const cancelAllContactSequences = `-- name: CancelAllContactSequences :exec
UPDATE contact_sequence_state
SET is_active = 0, unsubscribed_at = datetime('now')
WHERE contact_id = ?1
  AND sequence_id IN (SELECT id FROM email_sequences WHERE org_id = ?2)
`

type CancelAllContactSequencesParams struct {
	ContactID sql.NullString `json:"contact_id"`
	OrgID     sql.NullString `json:"org_id"`
}

func (q *Queries) CancelAllContactSequences(ctx context.Context, arg CancelAllContactSequencesParams) error {
	_, err := q.db.ExecContext(ctx, cancelAllContactSequences, arg.ContactID, arg.OrgID)
	return err
}

const cancelContactSequence = `-- name: CancelContactSequence :exec
UPDATE contact_sequence_state
SET is_active = 0, unsubscribed_at = datetime('now')
WHERE contact_id = ?1 AND sequence_id = ?2
`

type CancelContactSequenceParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

func (q *Queries) CancelContactSequence(ctx context.Context, arg CancelContactSequenceParams) error {
	_, err := q.db.ExecContext(ctx, cancelContactSequence, arg.ContactID, arg.SequenceID)
	return err
}

const cancelEmail = `-- name: CancelEmail :exec
UPDATE email_queue
SET status = 'cancelled'
WHERE id = ?1 AND status = 'pending'
`

func (q *Queries) CancelEmail(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, cancelEmail, id)
	return err
}

const cancelEmailsForContact = `-- name: CancelEmailsForContact :exec
UPDATE email_queue
SET status = 'cancelled'
WHERE contact_id = ?1 AND status = 'pending'
`

func (q *Queries) CancelEmailsForContact(ctx context.Context, contactID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, cancelEmailsForContact, contactID)
	return err
}

const cancelPendingEmailsForContactSequence = `-- name: CancelPendingEmailsForContactSequence :exec
UPDATE email_queue
SET status = 'cancelled'
WHERE contact_id = ?1
  AND template_id IN (SELECT id FROM email_templates WHERE sequence_id = ?2)
  AND status = 'pending'
`

type CancelPendingEmailsForContactSequenceParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

func (q *Queries) CancelPendingEmailsForContactSequence(ctx context.Context, arg CancelPendingEmailsForContactSequenceParams) error {
	_, err := q.db.ExecContext(ctx, cancelPendingEmailsForContactSequence, arg.ContactID, arg.SequenceID)
	return err
}

const completeContactSequence = `-- name: CompleteContactSequence :exec
UPDATE contact_sequence_state
SET completed_at = datetime('now')
WHERE contact_id = ?1 AND sequence_id = ?2
`

type CompleteContactSequenceParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

func (q *Queries) CompleteContactSequence(ctx context.Context, arg CompleteContactSequenceParams) error {
	_, err := q.db.ExecContext(ctx, completeContactSequence, arg.ContactID, arg.SequenceID)
	return err
}

const countTemplatesBySequence = `-- name: CountTemplatesBySequence :one
SELECT COUNT(*) as count
FROM email_templates
WHERE sequence_id = ?1 AND is_active = 1
`

func (q *Queries) CountTemplatesBySequence(ctx context.Context, sequenceID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTemplatesBySequence, sequenceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContactSequenceState = `-- name: CreateContactSequenceState :one
INSERT INTO contact_sequence_state (id, contact_id, sequence_id, current_position, started_at)
VALUES (?1, ?2, ?3, ?4, datetime('now'))
RETURNING id, contact_id, sequence_id, current_position, is_active, started_at, completed_at, unsubscribed_at, paused_at
`

type CreateContactSequenceStateParams struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	CurrentPosition sql.NullInt64  `json:"current_position"`
}

func (q *Queries) CreateContactSequenceState(ctx context.Context, arg CreateContactSequenceStateParams) (ContactSequenceState, error) {
	row := q.db.QueryRowContext(ctx, createContactSequenceState,
		arg.ID,
		arg.ContactID,
		arg.SequenceID,
		arg.CurrentPosition,
	)
	var i ContactSequenceState
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SequenceID,
		&i.CurrentPosition,
		&i.IsActive,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UnsubscribedAt,
		&i.PausedAt,
	)
	return i, err
}

const createEmailClick = `-- name: CreateEmailClick :one
INSERT INTO email_clicks (id, email_queue_id, contact_id, link_url, link_name, user_agent, ip_address, clicked_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, datetime('now'))
RETURNING id, email_queue_id, contact_id, link_url, link_name, clicked_at, user_agent, ip_address
`

type CreateEmailClickParams struct {
	ID           string         `json:"id"`
	EmailQueueID sql.NullString `json:"email_queue_id"`
	ContactID    sql.NullString `json:"contact_id"`
	LinkUrl      string         `json:"link_url"`
	LinkName     sql.NullString `json:"link_name"`
	UserAgent    sql.NullString `json:"user_agent"`
	IpAddress    sql.NullString `json:"ip_address"`
}

func (q *Queries) CreateEmailClick(ctx context.Context, arg CreateEmailClickParams) (EmailClick, error) {
	row := q.db.QueryRowContext(ctx, createEmailClick,
		arg.ID,
		arg.EmailQueueID,
		arg.ContactID,
		arg.LinkUrl,
		arg.LinkName,
		arg.UserAgent,
		arg.IpAddress,
	)
	var i EmailClick
	err := row.Scan(
		&i.ID,
		&i.EmailQueueID,
		&i.ContactID,
		&i.LinkUrl,
		&i.LinkName,
		&i.ClickedAt,
		&i.UserAgent,
		&i.IpAddress,
	)
	return i, err
}

const createSequence = `-- name: CreateSequence :one
INSERT INTO email_sequences (id, org_id, list_id, slug, name, trigger_event, is_active, sequence_type, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, COALESCE(?8, 'lifecycle'), datetime('now'))
RETURNING id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
`

type CreateSequenceParams struct {
	ID           string         `json:"id"`
	OrgID        sql.NullString `json:"org_id"`
	ListID       sql.NullInt64  `json:"list_id"`
	Slug         string         `json:"slug"`
	Name         string         `json:"name"`
	TriggerEvent string         `json:"trigger_event"`
	IsActive     sql.NullInt64  `json:"is_active"`
	SequenceType interface{}    `json:"sequence_type"`
}

func (q *Queries) CreateSequence(ctx context.Context, arg CreateSequenceParams) (EmailSequence, error) {
	row := q.db.QueryRowContext(ctx, createSequence,
		arg.ID,
		arg.OrgID,
		arg.ListID,
		arg.Slug,
		arg.Name,
		arg.TriggerEvent,
		arg.IsActive,
		arg.SequenceType,
	)
	var i EmailSequence
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Slug,
		&i.Name,
		&i.TriggerEvent,
		&i.IsActive,
		&i.SendHour,
		&i.SendTimezone,
		&i.SequenceType,
		&i.CreatedAt,
	)
	return i, err
}

const createTemplate = `-- name: CreateTemplate :one
INSERT INTO email_templates (id, sequence_id, position, delay_hours, subject, html_body, plain_text, template_type, is_active, design_id, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, datetime('now'))
RETURNING id, org_id, sequence_id, design_id, position, delay_hours, subject, html_body, plain_text, template_type, is_active, is_transactional, created_at
`

type CreateTemplateParams struct {
	ID           string         `json:"id"`
	SequenceID   sql.NullString `json:"sequence_id"`
	Position     int64          `json:"position"`
	DelayHours   int64          `json:"delay_hours"`
	Subject      string         `json:"subject"`
	HtmlBody     string         `json:"html_body"`
	PlainText    sql.NullString `json:"plain_text"`
	TemplateType sql.NullString `json:"template_type"`
	IsActive     sql.NullInt64  `json:"is_active"`
	DesignID     sql.NullInt64  `json:"design_id"`
}

func (q *Queries) CreateTemplate(ctx context.Context, arg CreateTemplateParams) (EmailTemplate, error) {
	row := q.db.QueryRowContext(ctx, createTemplate,
		arg.ID,
		arg.SequenceID,
		arg.Position,
		arg.DelayHours,
		arg.Subject,
		arg.HtmlBody,
		arg.PlainText,
		arg.TemplateType,
		arg.IsActive,
		arg.DesignID,
	)
	var i EmailTemplate
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.SequenceID,
		&i.DesignID,
		&i.Position,
		&i.DelayHours,
		&i.Subject,
		&i.HtmlBody,
		&i.PlainText,
		&i.TemplateType,
		&i.IsActive,
		&i.IsTransactional,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSequence = `-- name: DeleteSequence :exec
DELETE FROM email_sequences WHERE id = ?1
`

func (q *Queries) DeleteSequence(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSequence, id)
	return err
}

const deleteTemplate = `-- name: DeleteTemplate :exec
DELETE FROM email_templates WHERE id = ?1
`

func (q *Queries) DeleteTemplate(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTemplate, id)
	return err
}

const getConfirmationTemplate = `-- name: GetConfirmationTemplate :one
SELECT id, sequence_id, position, delay_hours, subject, html_body, plain_text, template_type, is_active, is_transactional, design_id, created_at
FROM email_templates
WHERE sequence_id = ?1 AND template_type = 'confirmation' AND is_active = 1
`

type GetConfirmationTemplateRow struct {
	ID              string         `json:"id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	Position        int64          `json:"position"`
	DelayHours      int64          `json:"delay_hours"`
	Subject         string         `json:"subject"`
	HtmlBody        string         `json:"html_body"`
	PlainText       sql.NullString `json:"plain_text"`
	TemplateType    sql.NullString `json:"template_type"`
	IsActive        sql.NullInt64  `json:"is_active"`
	IsTransactional sql.NullInt64  `json:"is_transactional"`
	DesignID        sql.NullInt64  `json:"design_id"`
	CreatedAt       sql.NullString `json:"created_at"`
}

func (q *Queries) GetConfirmationTemplate(ctx context.Context, sequenceID sql.NullString) (GetConfirmationTemplateRow, error) {
	row := q.db.QueryRowContext(ctx, getConfirmationTemplate, sequenceID)
	var i GetConfirmationTemplateRow
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.Position,
		&i.DelayHours,
		&i.Subject,
		&i.HtmlBody,
		&i.PlainText,
		&i.TemplateType,
		&i.IsActive,
		&i.IsTransactional,
		&i.DesignID,
		&i.CreatedAt,
	)
	return i, err
}

const getContactByTrackingToken = `-- name: GetContactByTrackingToken :one
SELECT c.id, c.org_id, c.name, c.email, c.source, c.created_at, c.updated_at, c.email_verified, c.verification_token, c.verification_sent_at, c.verified_at, c.unsubscribed_at, c.blocked_at, c.status, c.gdpr_consent, c.gdpr_consent_at FROM contacts c
JOIN email_queue eq ON eq.contact_id = c.id
WHERE eq.tracking_token = ?1
`

func (q *Queries) GetContactByTrackingToken(ctx context.Context, trackingToken sql.NullString) (Contact, error) {
	row := q.db.QueryRowContext(ctx, getContactByTrackingToken, trackingToken)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Email,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerified,
		&i.VerificationToken,
		&i.VerificationSentAt,
		&i.VerifiedAt,
		&i.UnsubscribedAt,
		&i.BlockedAt,
		&i.Status,
		&i.GdprConsent,
		&i.GdprConsentAt,
	)
	return i, err
}

const getContactSequenceState = `-- name: GetContactSequenceState :one
SELECT id, contact_id, sequence_id, current_position, started_at, completed_at, unsubscribed_at, is_active, paused_at
FROM contact_sequence_state
WHERE contact_id = ?1 AND sequence_id = ?2
`

type GetContactSequenceStateParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

type GetContactSequenceStateRow struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	CurrentPosition sql.NullInt64  `json:"current_position"`
	StartedAt       sql.NullString `json:"started_at"`
	CompletedAt     sql.NullString `json:"completed_at"`
	UnsubscribedAt  sql.NullString `json:"unsubscribed_at"`
	IsActive        sql.NullInt64  `json:"is_active"`
	PausedAt        sql.NullString `json:"paused_at"`
}

func (q *Queries) GetContactSequenceState(ctx context.Context, arg GetContactSequenceStateParams) (GetContactSequenceStateRow, error) {
	row := q.db.QueryRowContext(ctx, getContactSequenceState, arg.ContactID, arg.SequenceID)
	var i GetContactSequenceStateRow
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SequenceID,
		&i.CurrentPosition,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UnsubscribedAt,
		&i.IsActive,
		&i.PausedAt,
	)
	return i, err
}

const getContactSequenceStateWithDetails = `-- name: GetContactSequenceStateWithDetails :one
SELECT
    css.id, css.contact_id, css.sequence_id, css.current_position,
    css.started_at, css.completed_at, css.unsubscribed_at, css.is_active, css.paused_at,
    es.slug as sequence_slug, es.name as sequence_name,
    (SELECT COUNT(*) FROM email_templates et WHERE et.sequence_id = css.sequence_id AND et.is_active = 1) as total_steps,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.status = 'sent') as emails_sent,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.opened_at IS NOT NULL) as emails_opened,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.clicked_at IS NOT NULL) as emails_clicked,
    (SELECT eq.scheduled_for FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.status = 'pending'
     ORDER BY eq.scheduled_for LIMIT 1) as next_email_at
FROM contact_sequence_state css
JOIN email_sequences es ON es.id = css.sequence_id
WHERE css.contact_id = ?1 AND es.org_id = ?2 AND es.slug = ?3
`

type GetContactSequenceStateWithDetailsParams struct {
	ContactID sql.NullString `json:"contact_id"`
	OrgID     sql.NullString `json:"org_id"`
	Slug      string         `json:"slug"`
}

type GetContactSequenceStateWithDetailsRow struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	CurrentPosition sql.NullInt64  `json:"current_position"`
	StartedAt       sql.NullString `json:"started_at"`
	CompletedAt     sql.NullString `json:"completed_at"`
	UnsubscribedAt  sql.NullString `json:"unsubscribed_at"`
	IsActive        sql.NullInt64  `json:"is_active"`
	PausedAt        sql.NullString `json:"paused_at"`
	SequenceSlug    string         `json:"sequence_slug"`
	SequenceName    string         `json:"sequence_name"`
	TotalSteps      int64          `json:"total_steps"`
	EmailsSent      int64          `json:"emails_sent"`
	EmailsOpened    int64          `json:"emails_opened"`
	EmailsClicked   int64          `json:"emails_clicked"`
	NextEmailAt     string         `json:"next_email_at"`
}

func (q *Queries) GetContactSequenceStateWithDetails(ctx context.Context, arg GetContactSequenceStateWithDetailsParams) (GetContactSequenceStateWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getContactSequenceStateWithDetails, arg.ContactID, arg.OrgID, arg.Slug)
	var i GetContactSequenceStateWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SequenceID,
		&i.CurrentPosition,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UnsubscribedAt,
		&i.IsActive,
		&i.PausedAt,
		&i.SequenceSlug,
		&i.SequenceName,
		&i.TotalSteps,
		&i.EmailsSent,
		&i.EmailsOpened,
		&i.EmailsClicked,
		&i.NextEmailAt,
	)
	return i, err
}

const getEmailByTrackingToken = `-- name: GetEmailByTrackingToken :one
SELECT eq.id, eq.contact_id, eq.template_id, eq.scheduled_for, eq.sent_at, eq.status, eq.error_message, eq.created_at, eq.tracking_token, eq.opened_at, eq.open_count, eq.clicked_at, eq.click_count, c.email, c.name
FROM email_queue eq
JOIN contacts c ON c.id = eq.contact_id
WHERE eq.tracking_token = ?1
`

type GetEmailByTrackingTokenRow struct {
	ID            string         `json:"id"`
	ContactID     sql.NullString `json:"contact_id"`
	TemplateID    sql.NullString `json:"template_id"`
	ScheduledFor  string         `json:"scheduled_for"`
	SentAt        sql.NullString `json:"sent_at"`
	Status        sql.NullString `json:"status"`
	ErrorMessage  sql.NullString `json:"error_message"`
	CreatedAt     sql.NullString `json:"created_at"`
	TrackingToken sql.NullString `json:"tracking_token"`
	OpenedAt      sql.NullString `json:"opened_at"`
	OpenCount     int64          `json:"open_count"`
	ClickedAt     sql.NullString `json:"clicked_at"`
	ClickCount    int64          `json:"click_count"`
	Email         string         `json:"email"`
	Name          string         `json:"name"`
}

func (q *Queries) GetEmailByTrackingToken(ctx context.Context, trackingToken sql.NullString) (GetEmailByTrackingTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailByTrackingToken, trackingToken)
	var i GetEmailByTrackingTokenRow
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.TemplateID,
		&i.ScheduledFor,
		&i.SentAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TrackingToken,
		&i.OpenedAt,
		&i.OpenCount,
		&i.ClickedAt,
		&i.ClickCount,
		&i.Email,
		&i.Name,
	)
	return i, err
}

const getEmailQueueForContact = `-- name: GetEmailQueueForContact :many
SELECT eq.id, eq.contact_id, eq.template_id, eq.scheduled_for, eq.sent_at, eq.status, eq.error_message, eq.created_at, eq.tracking_token, eq.opened_at, eq.open_count, eq.clicked_at, eq.click_count, et.subject, et.position
FROM email_queue eq
JOIN email_templates et ON et.id = eq.template_id
WHERE eq.contact_id = ?1
ORDER BY eq.scheduled_for
`

type GetEmailQueueForContactRow struct {
	ID            string         `json:"id"`
	ContactID     sql.NullString `json:"contact_id"`
	TemplateID    sql.NullString `json:"template_id"`
	ScheduledFor  string         `json:"scheduled_for"`
	SentAt        sql.NullString `json:"sent_at"`
	Status        sql.NullString `json:"status"`
	ErrorMessage  sql.NullString `json:"error_message"`
	CreatedAt     sql.NullString `json:"created_at"`
	TrackingToken sql.NullString `json:"tracking_token"`
	OpenedAt      sql.NullString `json:"opened_at"`
	OpenCount     int64          `json:"open_count"`
	ClickedAt     sql.NullString `json:"clicked_at"`
	ClickCount    int64          `json:"click_count"`
	Subject       string         `json:"subject"`
	Position      int64          `json:"position"`
}

func (q *Queries) GetEmailQueueForContact(ctx context.Context, contactID sql.NullString) ([]GetEmailQueueForContactRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmailQueueForContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmailQueueForContactRow
	for rows.Next() {
		var i GetEmailQueueForContactRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.TemplateID,
			&i.ScheduledFor,
			&i.SentAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.TrackingToken,
			&i.OpenedAt,
			&i.OpenCount,
			&i.ClickedAt,
			&i.ClickCount,
			&i.Subject,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailStatsForSequence = `-- name: GetEmailStatsForSequence :one
SELECT
    SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_count,
    SUM(CASE WHEN opened_at IS NOT NULL THEN 1 ELSE 0 END) as opened_count,
    SUM(CASE WHEN clicked_at IS NOT NULL THEN 1 ELSE 0 END) as clicked_count,
    COALESCE(SUM(open_count), 0) as total_opens,
    COALESCE(SUM(click_count), 0) as total_clicks
FROM email_queue eq
JOIN email_templates et ON et.id = eq.template_id
WHERE et.sequence_id = ?1
`

type GetEmailStatsForSequenceRow struct {
	SentCount    sql.NullFloat64 `json:"sent_count"`
	OpenedCount  sql.NullFloat64 `json:"opened_count"`
	ClickedCount sql.NullFloat64 `json:"clicked_count"`
	TotalOpens   interface{}     `json:"total_opens"`
	TotalClicks  interface{}     `json:"total_clicks"`
}

func (q *Queries) GetEmailStatsForSequence(ctx context.Context, sequenceID sql.NullString) (GetEmailStatsForSequenceRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailStatsForSequence, sequenceID)
	var i GetEmailStatsForSequenceRow
	err := row.Scan(
		&i.SentCount,
		&i.OpenedCount,
		&i.ClickedCount,
		&i.TotalOpens,
		&i.TotalClicks,
	)
	return i, err
}

const getEmailStatsForTemplate = `-- name: GetEmailStatsForTemplate :one
SELECT
    SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_count,
    SUM(CASE WHEN opened_at IS NOT NULL THEN 1 ELSE 0 END) as opened_count,
    SUM(CASE WHEN clicked_at IS NOT NULL THEN 1 ELSE 0 END) as clicked_count,
    COALESCE(SUM(open_count), 0) as total_opens,
    COALESCE(SUM(click_count), 0) as total_clicks
FROM email_queue
WHERE template_id = ?1
`

type GetEmailStatsForTemplateRow struct {
	SentCount    sql.NullFloat64 `json:"sent_count"`
	OpenedCount  sql.NullFloat64 `json:"opened_count"`
	ClickedCount sql.NullFloat64 `json:"clicked_count"`
	TotalOpens   interface{}     `json:"total_opens"`
	TotalClicks  interface{}     `json:"total_clicks"`
}

func (q *Queries) GetEmailStatsForTemplate(ctx context.Context, templateID sql.NullString) (GetEmailStatsForTemplateRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailStatsForTemplate, templateID)
	var i GetEmailStatsForTemplateRow
	err := row.Scan(
		&i.SentCount,
		&i.OpenedCount,
		&i.ClickedCount,
		&i.TotalOpens,
		&i.TotalClicks,
	)
	return i, err
}

const getEmailStatsInDateRange = `-- name: GetEmailStatsInDateRange :one
SELECT
    SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_count,
    SUM(CASE WHEN opened_at IS NOT NULL THEN 1 ELSE 0 END) as opened_count,
    SUM(CASE WHEN clicked_at IS NOT NULL THEN 1 ELSE 0 END) as clicked_count,
    COALESCE(SUM(open_count), 0) as total_opens,
    COALESCE(SUM(click_count), 0) as total_clicks
FROM email_queue
WHERE sent_at >= ?1 AND sent_at <= ?2
`

type GetEmailStatsInDateRangeParams struct {
	StartDate sql.NullString `json:"start_date"`
	EndDate   sql.NullString `json:"end_date"`
}

type GetEmailStatsInDateRangeRow struct {
	SentCount    sql.NullFloat64 `json:"sent_count"`
	OpenedCount  sql.NullFloat64 `json:"opened_count"`
	ClickedCount sql.NullFloat64 `json:"clicked_count"`
	TotalOpens   interface{}     `json:"total_opens"`
	TotalClicks  interface{}     `json:"total_clicks"`
}

func (q *Queries) GetEmailStatsInDateRange(ctx context.Context, arg GetEmailStatsInDateRangeParams) (GetEmailStatsInDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailStatsInDateRange, arg.StartDate, arg.EndDate)
	var i GetEmailStatsInDateRangeRow
	err := row.Scan(
		&i.SentCount,
		&i.OpenedCount,
		&i.ClickedCount,
		&i.TotalOpens,
		&i.TotalClicks,
	)
	return i, err
}

const getNextTemplate = `-- name: GetNextTemplate :one
SELECT id, sequence_id, position, delay_hours, subject, html_body, plain_text, is_active, is_transactional, design_id, created_at
FROM email_templates
WHERE sequence_id = ?1 AND position = ?2 AND is_active = 1
`

type GetNextTemplateParams struct {
	SequenceID sql.NullString `json:"sequence_id"`
	Position   int64          `json:"position"`
}

type GetNextTemplateRow struct {
	ID              string         `json:"id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	Position        int64          `json:"position"`
	DelayHours      int64          `json:"delay_hours"`
	Subject         string         `json:"subject"`
	HtmlBody        string         `json:"html_body"`
	PlainText       sql.NullString `json:"plain_text"`
	IsActive        sql.NullInt64  `json:"is_active"`
	IsTransactional sql.NullInt64  `json:"is_transactional"`
	DesignID        sql.NullInt64  `json:"design_id"`
	CreatedAt       sql.NullString `json:"created_at"`
}

func (q *Queries) GetNextTemplate(ctx context.Context, arg GetNextTemplateParams) (GetNextTemplateRow, error) {
	row := q.db.QueryRowContext(ctx, getNextTemplate, arg.SequenceID, arg.Position)
	var i GetNextTemplateRow
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.Position,
		&i.DelayHours,
		&i.Subject,
		&i.HtmlBody,
		&i.PlainText,
		&i.IsActive,
		&i.IsTransactional,
		&i.DesignID,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingEmails = `-- name: GetPendingEmails :many
SELECT eq.id, eq.contact_id, eq.template_id, eq.scheduled_for, eq.status, eq.tracking_token,
       et.subject, et.html_body, et.template_type, et.is_transactional,
       c.email, c.name
FROM email_queue eq
JOIN email_templates et ON et.id = eq.template_id
JOIN contacts c ON c.id = eq.contact_id
WHERE eq.status = 'pending' AND eq.scheduled_for <= ?1 AND c.unsubscribed_at IS NULL
ORDER BY eq.scheduled_for
LIMIT ?2
`

type GetPendingEmailsParams struct {
	ScheduledBefore string `json:"scheduled_before"`
	LimitCount      int64  `json:"limit_count"`
}

type GetPendingEmailsRow struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	TemplateID      sql.NullString `json:"template_id"`
	ScheduledFor    string         `json:"scheduled_for"`
	Status          sql.NullString `json:"status"`
	TrackingToken   sql.NullString `json:"tracking_token"`
	Subject         string         `json:"subject"`
	HtmlBody        string         `json:"html_body"`
	TemplateType    sql.NullString `json:"template_type"`
	IsTransactional sql.NullInt64  `json:"is_transactional"`
	Email           string         `json:"email"`
	Name            string         `json:"name"`
}

func (q *Queries) GetPendingEmails(ctx context.Context, arg GetPendingEmailsParams) ([]GetPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingEmails, arg.ScheduledBefore, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingEmailsRow
	for rows.Next() {
		var i GetPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.TemplateID,
			&i.ScheduledFor,
			&i.Status,
			&i.TrackingToken,
			&i.Subject,
			&i.HtmlBody,
			&i.TemplateType,
			&i.IsTransactional,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSequenceByID = `-- name: GetSequenceByID :one
SELECT id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
FROM email_sequences
WHERE id = ?1
`

func (q *Queries) GetSequenceByID(ctx context.Context, id string) (EmailSequence, error) {
	row := q.db.QueryRowContext(ctx, getSequenceByID, id)
	var i EmailSequence
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Slug,
		&i.Name,
		&i.TriggerEvent,
		&i.IsActive,
		&i.SendHour,
		&i.SendTimezone,
		&i.SequenceType,
		&i.CreatedAt,
	)
	return i, err
}

const getSequenceByListAndSlug = `-- name: GetSequenceByListAndSlug :one
SELECT id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
FROM email_sequences
WHERE list_id = ?1 AND slug = ?2
`

type GetSequenceByListAndSlugParams struct {
	ListID sql.NullInt64 `json:"list_id"`
	Slug   string        `json:"slug"`
}

func (q *Queries) GetSequenceByListAndSlug(ctx context.Context, arg GetSequenceByListAndSlugParams) (EmailSequence, error) {
	row := q.db.QueryRowContext(ctx, getSequenceByListAndSlug, arg.ListID, arg.Slug)
	var i EmailSequence
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Slug,
		&i.Name,
		&i.TriggerEvent,
		&i.IsActive,
		&i.SendHour,
		&i.SendTimezone,
		&i.SequenceType,
		&i.CreatedAt,
	)
	return i, err
}

const getSequenceByListAndTrigger = `-- name: GetSequenceByListAndTrigger :one
SELECT id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
FROM email_sequences
WHERE list_id = ?1 AND trigger_event = ?2 AND is_active = 1
`

type GetSequenceByListAndTriggerParams struct {
	ListID       sql.NullInt64 `json:"list_id"`
	TriggerEvent string        `json:"trigger_event"`
}

func (q *Queries) GetSequenceByListAndTrigger(ctx context.Context, arg GetSequenceByListAndTriggerParams) (EmailSequence, error) {
	row := q.db.QueryRowContext(ctx, getSequenceByListAndTrigger, arg.ListID, arg.TriggerEvent)
	var i EmailSequence
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Slug,
		&i.Name,
		&i.TriggerEvent,
		&i.IsActive,
		&i.SendHour,
		&i.SendTimezone,
		&i.SequenceType,
		&i.CreatedAt,
	)
	return i, err
}

const getSequenceByOrgAndSlug = `-- name: GetSequenceByOrgAndSlug :one

SELECT id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
FROM email_sequences
WHERE org_id = ?1 AND slug = ?2
`

type GetSequenceByOrgAndSlugParams struct {
	OrgID sql.NullString `json:"org_id"`
	Slug  string         `json:"slug"`
}

// SDK Sequence queries
func (q *Queries) GetSequenceByOrgAndSlug(ctx context.Context, arg GetSequenceByOrgAndSlugParams) (EmailSequence, error) {
	row := q.db.QueryRowContext(ctx, getSequenceByOrgAndSlug, arg.OrgID, arg.Slug)
	var i EmailSequence
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ListID,
		&i.Slug,
		&i.Name,
		&i.TriggerEvent,
		&i.IsActive,
		&i.SendHour,
		&i.SendTimezone,
		&i.SequenceType,
		&i.CreatedAt,
	)
	return i, err
}

const getSequenceStats = `-- name: GetSequenceStats :one
SELECT
    COUNT(DISTINCT css.contact_id) as total_subscribers,
    COUNT(DISTINCT CASE WHEN css.completed_at IS NOT NULL THEN css.contact_id END) as completed,
    COUNT(DISTINCT CASE WHEN css.unsubscribed_at IS NOT NULL THEN css.contact_id END) as unsubscribed,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE et.sequence_id = ?1 AND eq.status = 'sent') as emails_sent,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE et.sequence_id = ?1 AND eq.status = 'pending') as emails_pending
FROM contact_sequence_state css
WHERE css.sequence_id = ?1
`

type GetSequenceStatsRow struct {
	TotalSubscribers int64 `json:"total_subscribers"`
	Completed        int64 `json:"completed"`
	Unsubscribed     int64 `json:"unsubscribed"`
	EmailsSent       int64 `json:"emails_sent"`
	EmailsPending    int64 `json:"emails_pending"`
}

func (q *Queries) GetSequenceStats(ctx context.Context, sequenceID sql.NullString) (GetSequenceStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSequenceStats, sequenceID)
	var i GetSequenceStatsRow
	err := row.Scan(
		&i.TotalSubscribers,
		&i.Completed,
		&i.Unsubscribed,
		&i.EmailsSent,
		&i.EmailsPending,
	)
	return i, err
}

const getTemplateByID = `-- name: GetTemplateByID :one
SELECT id, sequence_id, position, delay_hours, subject, html_body, plain_text, template_type, is_active, design_id, created_at
FROM email_templates
WHERE id = ?1
`

type GetTemplateByIDRow struct {
	ID           string         `json:"id"`
	SequenceID   sql.NullString `json:"sequence_id"`
	Position     int64          `json:"position"`
	DelayHours   int64          `json:"delay_hours"`
	Subject      string         `json:"subject"`
	HtmlBody     string         `json:"html_body"`
	PlainText    sql.NullString `json:"plain_text"`
	TemplateType sql.NullString `json:"template_type"`
	IsActive     sql.NullInt64  `json:"is_active"`
	DesignID     sql.NullInt64  `json:"design_id"`
	CreatedAt    sql.NullString `json:"created_at"`
}

func (q *Queries) GetTemplateByID(ctx context.Context, id string) (GetTemplateByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTemplateByID, id)
	var i GetTemplateByIDRow
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.Position,
		&i.DelayHours,
		&i.Subject,
		&i.HtmlBody,
		&i.PlainText,
		&i.TemplateType,
		&i.IsActive,
		&i.DesignID,
		&i.CreatedAt,
	)
	return i, err
}

const listAllSequences = `-- name: ListAllSequences :many
SELECT es.id, es.org_id, es.list_id, es.slug, es.name, es.trigger_event, es.is_active,
       es.send_hour, es.send_timezone, es.sequence_type, es.created_at,
       el.name as list_name, el.slug as list_slug
FROM email_sequences es
LEFT JOIN email_lists el ON el.id = es.list_id
ORDER BY es.created_at
`

type ListAllSequencesRow struct {
	ID           string         `json:"id"`
	OrgID        sql.NullString `json:"org_id"`
	ListID       sql.NullInt64  `json:"list_id"`
	Slug         string         `json:"slug"`
	Name         string         `json:"name"`
	TriggerEvent string         `json:"trigger_event"`
	IsActive     sql.NullInt64  `json:"is_active"`
	SendHour     sql.NullInt64  `json:"send_hour"`
	SendTimezone sql.NullString `json:"send_timezone"`
	SequenceType sql.NullString `json:"sequence_type"`
	CreatedAt    sql.NullString `json:"created_at"`
	ListName     sql.NullString `json:"list_name"`
	ListSlug     sql.NullString `json:"list_slug"`
}

func (q *Queries) ListAllSequences(ctx context.Context) ([]ListAllSequencesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllSequences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllSequencesRow
	for rows.Next() {
		var i ListAllSequencesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ListID,
			&i.Slug,
			&i.Name,
			&i.TriggerEvent,
			&i.IsActive,
			&i.SendHour,
			&i.SendTimezone,
			&i.SequenceType,
			&i.CreatedAt,
			&i.ListName,
			&i.ListSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactSequenceStatesWithDetails = `-- name: ListContactSequenceStatesWithDetails :many
SELECT
    css.id, css.contact_id, css.sequence_id, css.current_position,
    css.started_at, css.completed_at, css.unsubscribed_at, css.is_active, css.paused_at,
    es.slug as sequence_slug, es.name as sequence_name,
    (SELECT COUNT(*) FROM email_templates et WHERE et.sequence_id = css.sequence_id AND et.is_active = 1) as total_steps,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.status = 'sent') as emails_sent,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.opened_at IS NOT NULL) as emails_opened,
    (SELECT COUNT(*) FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.clicked_at IS NOT NULL) as emails_clicked,
    (SELECT eq.scheduled_for FROM email_queue eq
     JOIN email_templates et ON et.id = eq.template_id
     WHERE eq.contact_id = css.contact_id AND et.sequence_id = css.sequence_id AND eq.status = 'pending'
     ORDER BY eq.scheduled_for LIMIT 1) as next_email_at
FROM contact_sequence_state css
JOIN email_sequences es ON es.id = css.sequence_id
WHERE css.contact_id = ?1 AND es.org_id = ?2
`

type ListContactSequenceStatesWithDetailsParams struct {
	ContactID sql.NullString `json:"contact_id"`
	OrgID     sql.NullString `json:"org_id"`
}

type ListContactSequenceStatesWithDetailsRow struct {
	ID              string         `json:"id"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
	CurrentPosition sql.NullInt64  `json:"current_position"`
	StartedAt       sql.NullString `json:"started_at"`
	CompletedAt     sql.NullString `json:"completed_at"`
	UnsubscribedAt  sql.NullString `json:"unsubscribed_at"`
	IsActive        sql.NullInt64  `json:"is_active"`
	PausedAt        sql.NullString `json:"paused_at"`
	SequenceSlug    string         `json:"sequence_slug"`
	SequenceName    string         `json:"sequence_name"`
	TotalSteps      int64          `json:"total_steps"`
	EmailsSent      int64          `json:"emails_sent"`
	EmailsOpened    int64          `json:"emails_opened"`
	EmailsClicked   int64          `json:"emails_clicked"`
	NextEmailAt     string         `json:"next_email_at"`
}

func (q *Queries) ListContactSequenceStatesWithDetails(ctx context.Context, arg ListContactSequenceStatesWithDetailsParams) ([]ListContactSequenceStatesWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactSequenceStatesWithDetails, arg.ContactID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContactSequenceStatesWithDetailsRow
	for rows.Next() {
		var i ListContactSequenceStatesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.SequenceID,
			&i.CurrentPosition,
			&i.StartedAt,
			&i.CompletedAt,
			&i.UnsubscribedAt,
			&i.IsActive,
			&i.PausedAt,
			&i.SequenceSlug,
			&i.SequenceName,
			&i.TotalSteps,
			&i.EmailsSent,
			&i.EmailsOpened,
			&i.EmailsClicked,
			&i.NextEmailAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmailQueueByOrg = `-- name: ListEmailQueueByOrg :many
SELECT eq.id, eq.contact_id, eq.template_id, eq.scheduled_for, eq.sent_at, eq.status, eq.error_message,
       et.subject, c.email as contact_email, c.name as contact_name
FROM email_queue eq
JOIN email_templates et ON et.id = eq.template_id
JOIN email_sequences es ON es.id = et.sequence_id
JOIN contacts c ON c.id = eq.contact_id
WHERE es.org_id = ?1
  AND (?2 IS NULL OR ?2 = '' OR eq.status = ?2)
  AND (?3 IS NULL OR ?3 = '' OR eq.contact_id = ?3)
ORDER BY eq.scheduled_for DESC
`

type ListEmailQueueByOrgParams struct {
	OrgID           sql.NullString `json:"org_id"`
	FilterStatus    interface{}    `json:"filter_status"`
	FilterContactID interface{}    `json:"filter_contact_id"`
}

type ListEmailQueueByOrgRow struct {
	ID           string         `json:"id"`
	ContactID    sql.NullString `json:"contact_id"`
	TemplateID   sql.NullString `json:"template_id"`
	ScheduledFor string         `json:"scheduled_for"`
	SentAt       sql.NullString `json:"sent_at"`
	Status       sql.NullString `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	Subject      string         `json:"subject"`
	ContactEmail string         `json:"contact_email"`
	ContactName  string         `json:"contact_name"`
}

func (q *Queries) ListEmailQueueByOrg(ctx context.Context, arg ListEmailQueueByOrgParams) ([]ListEmailQueueByOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, listEmailQueueByOrg, arg.OrgID, arg.FilterStatus, arg.FilterContactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmailQueueByOrgRow
	for rows.Next() {
		var i ListEmailQueueByOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.TemplateID,
			&i.ScheduledFor,
			&i.SentAt,
			&i.Status,
			&i.ErrorMessage,
			&i.Subject,
			&i.ContactEmail,
			&i.ContactName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSequencesByList = `-- name: ListSequencesByList :many
SELECT id, org_id, list_id, slug, name, trigger_event, is_active, send_hour, send_timezone, sequence_type, created_at
FROM email_sequences
WHERE list_id = ?1
ORDER BY created_at
`

func (q *Queries) ListSequencesByList(ctx context.Context, listID sql.NullInt64) ([]EmailSequence, error) {
	rows, err := q.db.QueryContext(ctx, listSequencesByList, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailSequence
	for rows.Next() {
		var i EmailSequence
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ListID,
			&i.Slug,
			&i.Name,
			&i.TriggerEvent,
			&i.IsActive,
			&i.SendHour,
			&i.SendTimezone,
			&i.SequenceType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSequencesByOrg = `-- name: ListSequencesByOrg :many
SELECT es.id, es.org_id, es.list_id, es.slug, es.name, es.trigger_event, es.is_active,
       es.send_hour, es.send_timezone, es.sequence_type, es.created_at,
       el.name as list_name, el.slug as list_slug
FROM email_sequences es
LEFT JOIN email_lists el ON el.id = es.list_id
WHERE es.org_id = ?1
ORDER BY es.created_at
`

type ListSequencesByOrgRow struct {
	ID           string         `json:"id"`
	OrgID        sql.NullString `json:"org_id"`
	ListID       sql.NullInt64  `json:"list_id"`
	Slug         string         `json:"slug"`
	Name         string         `json:"name"`
	TriggerEvent string         `json:"trigger_event"`
	IsActive     sql.NullInt64  `json:"is_active"`
	SendHour     sql.NullInt64  `json:"send_hour"`
	SendTimezone sql.NullString `json:"send_timezone"`
	SequenceType sql.NullString `json:"sequence_type"`
	CreatedAt    sql.NullString `json:"created_at"`
	ListName     sql.NullString `json:"list_name"`
	ListSlug     sql.NullString `json:"list_slug"`
}

func (q *Queries) ListSequencesByOrg(ctx context.Context, orgID sql.NullString) ([]ListSequencesByOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, listSequencesByOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSequencesByOrgRow
	for rows.Next() {
		var i ListSequencesByOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ListID,
			&i.Slug,
			&i.Name,
			&i.TriggerEvent,
			&i.IsActive,
			&i.SendHour,
			&i.SendTimezone,
			&i.SequenceType,
			&i.CreatedAt,
			&i.ListName,
			&i.ListSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTemplatesBySequence = `-- name: ListTemplatesBySequence :many
SELECT id, sequence_id, position, delay_hours, subject, html_body, plain_text, template_type, is_active, design_id, created_at
FROM email_templates
WHERE sequence_id = ?1
ORDER BY position
`

type ListTemplatesBySequenceRow struct {
	ID           string         `json:"id"`
	SequenceID   sql.NullString `json:"sequence_id"`
	Position     int64          `json:"position"`
	DelayHours   int64          `json:"delay_hours"`
	Subject      string         `json:"subject"`
	HtmlBody     string         `json:"html_body"`
	PlainText    sql.NullString `json:"plain_text"`
	TemplateType sql.NullString `json:"template_type"`
	IsActive     sql.NullInt64  `json:"is_active"`
	DesignID     sql.NullInt64  `json:"design_id"`
	CreatedAt    sql.NullString `json:"created_at"`
}

func (q *Queries) ListTemplatesBySequence(ctx context.Context, sequenceID sql.NullString) ([]ListTemplatesBySequenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listTemplatesBySequence, sequenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTemplatesBySequenceRow
	for rows.Next() {
		var i ListTemplatesBySequenceRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceID,
			&i.Position,
			&i.DelayHours,
			&i.Subject,
			&i.HtmlBody,
			&i.PlainText,
			&i.TemplateType,
			&i.IsActive,
			&i.DesignID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailFailed = `-- name: MarkEmailFailed :exec
UPDATE email_queue
SET status = 'failed', error_message = ?1
WHERE id = ?2
`

type MarkEmailFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) MarkEmailFailed(ctx context.Context, arg MarkEmailFailedParams) error {
	_, err := q.db.ExecContext(ctx, markEmailFailed, arg.ErrorMessage, arg.ID)
	return err
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE email_queue
SET status = 'sent', sent_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) MarkEmailSent(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markEmailSent, id)
	return err
}

const pauseContactSequence = `-- name: PauseContactSequence :exec
UPDATE contact_sequence_state
SET paused_at = datetime('now'), is_active = 0
WHERE contact_id = ?1 AND sequence_id = ?2
`

type PauseContactSequenceParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

func (q *Queries) PauseContactSequence(ctx context.Context, arg PauseContactSequenceParams) error {
	_, err := q.db.ExecContext(ctx, pauseContactSequence, arg.ContactID, arg.SequenceID)
	return err
}

const queueEmail = `-- name: QueueEmail :one
INSERT INTO email_queue (id, contact_id, template_id, scheduled_for, status, tracking_token, created_at)
VALUES (?1, ?2, ?3, ?4, 'pending', ?5, datetime('now'))
RETURNING id, contact_id, template_id, scheduled_for, sent_at, status, error_message, created_at, tracking_token, opened_at, open_count, clicked_at, click_count
`

type QueueEmailParams struct {
	ID            string         `json:"id"`
	ContactID     sql.NullString `json:"contact_id"`
	TemplateID    sql.NullString `json:"template_id"`
	ScheduledFor  string         `json:"scheduled_for"`
	TrackingToken sql.NullString `json:"tracking_token"`
}

func (q *Queries) QueueEmail(ctx context.Context, arg QueueEmailParams) (EmailQueue, error) {
	row := q.db.QueryRowContext(ctx, queueEmail,
		arg.ID,
		arg.ContactID,
		arg.TemplateID,
		arg.ScheduledFor,
		arg.TrackingToken,
	)
	var i EmailQueue
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.TemplateID,
		&i.ScheduledFor,
		&i.SentAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TrackingToken,
		&i.OpenedAt,
		&i.OpenCount,
		&i.ClickedAt,
		&i.ClickCount,
	)
	return i, err
}

const queueEmailWithTracking = `-- name: QueueEmailWithTracking :one

INSERT INTO email_queue (id, contact_id, template_id, scheduled_for, status, tracking_token, created_at)
VALUES (?1, ?2, ?3, ?4, 'pending', ?5, datetime('now'))
RETURNING id, contact_id, template_id, scheduled_for, sent_at, status, error_message, created_at, tracking_token, opened_at, open_count, clicked_at, click_count
`

type QueueEmailWithTrackingParams struct {
	ID            string         `json:"id"`
	ContactID     sql.NullString `json:"contact_id"`
	TemplateID    sql.NullString `json:"template_id"`
	ScheduledFor  string         `json:"scheduled_for"`
	TrackingToken sql.NullString `json:"tracking_token"`
}

// Email tracking queries
func (q *Queries) QueueEmailWithTracking(ctx context.Context, arg QueueEmailWithTrackingParams) (EmailQueue, error) {
	row := q.db.QueryRowContext(ctx, queueEmailWithTracking,
		arg.ID,
		arg.ContactID,
		arg.TemplateID,
		arg.ScheduledFor,
		arg.TrackingToken,
	)
	var i EmailQueue
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.TemplateID,
		&i.ScheduledFor,
		&i.SentAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TrackingToken,
		&i.OpenedAt,
		&i.OpenCount,
		&i.ClickedAt,
		&i.ClickCount,
	)
	return i, err
}

const recordEmailClick = `-- name: RecordEmailClick :exec
UPDATE email_queue
SET clicked_at = COALESCE(clicked_at, datetime('now')), click_count = click_count + 1
WHERE id = ?1
`

func (q *Queries) RecordEmailClick(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, recordEmailClick, id)
	return err
}

const recordEmailOpen = `-- name: RecordEmailOpen :exec
UPDATE email_queue
SET opened_at = COALESCE(opened_at, datetime('now')), open_count = open_count + 1
WHERE id = ?1
`

func (q *Queries) RecordEmailOpen(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, recordEmailOpen, id)
	return err
}

const resumeContactSequence = `-- name: ResumeContactSequence :exec
UPDATE contact_sequence_state
SET paused_at = NULL, is_active = 1
WHERE contact_id = ?1 AND sequence_id = ?2
`

type ResumeContactSequenceParams struct {
	ContactID  sql.NullString `json:"contact_id"`
	SequenceID sql.NullString `json:"sequence_id"`
}

func (q *Queries) ResumeContactSequence(ctx context.Context, arg ResumeContactSequenceParams) error {
	_, err := q.db.ExecContext(ctx, resumeContactSequence, arg.ContactID, arg.SequenceID)
	return err
}

const unsubscribeContact = `-- name: UnsubscribeContact :exec
UPDATE contacts
SET unsubscribed_at = datetime('now')
WHERE id = ?1
`

func (q *Queries) UnsubscribeContact(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, unsubscribeContact, id)
	return err
}

const unsubscribeContactFromSequence = `-- name: UnsubscribeContactFromSequence :exec
UPDATE contact_sequence_state
SET unsubscribed_at = datetime('now')
WHERE contact_id = ?1
`

func (q *Queries) UnsubscribeContactFromSequence(ctx context.Context, contactID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, unsubscribeContactFromSequence, contactID)
	return err
}

const updateContactSequencePosition = `-- name: UpdateContactSequencePosition :exec
UPDATE contact_sequence_state
SET current_position = ?1
WHERE contact_id = ?2 AND sequence_id = ?3
`

type UpdateContactSequencePositionParams struct {
	CurrentPosition sql.NullInt64  `json:"current_position"`
	ContactID       sql.NullString `json:"contact_id"`
	SequenceID      sql.NullString `json:"sequence_id"`
}

func (q *Queries) UpdateContactSequencePosition(ctx context.Context, arg UpdateContactSequencePositionParams) error {
	_, err := q.db.ExecContext(ctx, updateContactSequencePosition, arg.CurrentPosition, arg.ContactID, arg.SequenceID)
	return err
}

const updateSequence = `-- name: UpdateSequence :exec
UPDATE email_sequences
SET name = ?1, trigger_event = ?2, is_active = ?3, send_hour = ?4, send_timezone = ?5, sequence_type = COALESCE(?6, sequence_type)
WHERE id = ?7
`

type UpdateSequenceParams struct {
	Name         string         `json:"name"`
	TriggerEvent string         `json:"trigger_event"`
	IsActive     sql.NullInt64  `json:"is_active"`
	SendHour     sql.NullInt64  `json:"send_hour"`
	SendTimezone sql.NullString `json:"send_timezone"`
	SequenceType sql.NullString `json:"sequence_type"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateSequence(ctx context.Context, arg UpdateSequenceParams) error {
	_, err := q.db.ExecContext(ctx, updateSequence,
		arg.Name,
		arg.TriggerEvent,
		arg.IsActive,
		arg.SendHour,
		arg.SendTimezone,
		arg.SequenceType,
		arg.ID,
	)
	return err
}

const updateTemplate = `-- name: UpdateTemplate :exec
UPDATE email_templates
SET position = ?1, delay_hours = ?2, subject = ?3, html_body = ?4, plain_text = ?5, template_type = ?6, is_active = ?7, design_id = ?8
WHERE id = ?9
`

type UpdateTemplateParams struct {
	Position     int64          `json:"position"`
	DelayHours   int64          `json:"delay_hours"`
	Subject      string         `json:"subject"`
	HtmlBody     string         `json:"html_body"`
	PlainText    sql.NullString `json:"plain_text"`
	TemplateType sql.NullString `json:"template_type"`
	IsActive     sql.NullInt64  `json:"is_active"`
	DesignID     sql.NullInt64  `json:"design_id"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateTemplate(ctx context.Context, arg UpdateTemplateParams) error {
	_, err := q.db.ExecContext(ctx, updateTemplate,
		arg.Position,
		arg.DelayHours,
		arg.Subject,
		arg.HtmlBody,
		arg.PlainText,
		arg.TemplateType,
		arg.IsActive,
		arg.DesignID,
		arg.ID,
	)
	return err
}
